<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ€ç»´å¯¼å›¾é‡å æµ‹è¯• - åŸºäºObsidianæ’ä»¶å®ç°</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .mind-map-container {
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: auto;
            background: white;
        }
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .debug-info h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .debug-log {
            margin: 0;
            padding: 0;
            list-style: none;
        }
        .debug-log li {
            margin: 2px 0;
            padding: 2px 0;
        }
        .debug-log .error {
            color: #d32f2f;
            background: #ffebee;
        }
        .debug-log .success {
            color: #2e7d32;
            background: #e8f5e8;
        }
        .debug-log .info {
            color: #1976d2;
            background: #e3f2fd;
        }
        .overlap-highlight {
            fill: red;
            fill-opacity: 0.3;
            stroke: red;
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§  æ€ç»´å¯¼å›¾é‡å æµ‹è¯•</h1>
        <p>åŸºäºå½“å‰Obsidianæ’ä»¶çš„å®é™…å®ç°è¿›è¡Œæµ‹è¯• | <a href="test-data.md" target="_blank">æŸ¥çœ‹æµ‹è¯•æ•°æ®</a></p>

        <div class="controls">
            <button onclick="renderMindMap()">æ¸²æŸ“æ€ç»´å¯¼å›¾</button>
            <button onclick="detectAndHighlightOverlaps()">æ£€æµ‹é‡å </button>
            <button onclick="clearDebugInfo()">æ¸…ç©ºè°ƒè¯•ä¿¡æ¯</button>
            <button onclick="exportDebugData()">å¯¼å‡ºè°ƒè¯•æ•°æ®</button>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="mind-map-container">
            <svg id="mindmap" width="1600" height="1200" style="background: white;">
                <defs>
                    <linearGradient id="nodeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#f0f0f0;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <g id="content-group"></g>
                <g id="link-group"></g>
                <g id="node-group"></g>
                <g id="overlap-group"></g>
            </svg>
        </div>
    </div>

    <div class="debug-info">
        <h3>ğŸ” è°ƒè¯•ä¿¡æ¯</h3>
        <ul class="debug-log" id="debug-log">
            <li class="info">ç­‰å¾…æ¸²æŸ“æ€ç»´å¯¼å›¾...</li>
        </ul>
    </div>

    <script>
        // å®Œå…¨åŸºäºå½“å‰Obsidianæ’ä»¶å®ç°çš„é…ç½®ï¼ˆæœ€æ–°ä¼˜åŒ–ï¼‰
        const layoutConfig = {
            minNodeGap: 25,           // æœ€å°èŠ‚ç‚¹é—´è·ï¼ˆå¢åŠ ï¼‰
            lineOffset: 8,            // è¿çº¿ä¸èŠ‚ç‚¹è¾¹ç¼˜çš„å®‰å…¨è·ç¦»
            horizontalSpacing: 220,   // æ°´å¹³åŸºç¡€é—´è·
            verticalSpacing: 110,     // å‚ç›´åŸºç¡€é—´è·ï¼ˆè¿›ä¸€æ­¥å¢åŠ ï¼‰
            minVerticalGap: 25,       // æœ€å°å‚ç›´é—´è·ï¼ˆè¿›ä¸€æ­¥å¢åŠ ï¼‰
            treeHeight: 800,          // æ ‘é«˜åº¦ï¼ˆåŠ¨æ€è®¡ç®—ï¼‰
            treeWidth: 1400,          // æ ‘å®½åº¦
            nodeHeightBuffer: 15,     // èŠ‚ç‚¹é«˜åº¦ç¼“å†²ï¼ˆå¢åŠ å®‰å…¨è¾¹ç•Œï¼‰
        };

        // æ–‡æœ¬æµ‹é‡ç¼“å­˜
        const textMeasurementCache = new Map();

        // æµ‹è¯•æ•°æ® - ä½¿ç”¨å®é™…é¡¹ç›®ä¸­çš„å¤æ‚ç»“æ„
        const testData = {
            name: "test-mindmap",
            children: [
                {
                    name: "é¡¹ç›®ç®¡ç†",
                    children: [
                        {
                            name: "éœ€æ±‚åˆ†æ",
                            children: [
                                { name: "ç”¨æˆ·è°ƒç ”" },
                                { name: "åŠŸèƒ½è§„åˆ’" },
                                { name: "å¯è¡Œæ€§è¯„ä¼°" }
                            ]
                        },
                        {
                            name: "é¡¹ç›®è§„åˆ’",
                            children: [
                                { name: "æ—¶é—´å®‰æ’" },
                                { name: "èµ„æºåˆ†é…" },
                                { name: "é£é™©ç®¡ç†" }
                            ]
                        },
                        {
                            name: "å¼€å‘æ‰§è¡Œ",
                            children: [
                                {
                                    name: "å‰ç«¯å¼€å‘",
                                    children: [
                                        { name: "ç•Œé¢è®¾è®¡" },
                                        { name: "åŠŸèƒ½å®ç°" },
                                        { name: "ç”¨æˆ·æµ‹è¯•" }
                                    ]
                                },
                                {
                                    name: "åç«¯å¼€å‘",
                                    children: [
                                        { name: "æ•°æ®åº“è®¾è®¡" },
                                        { name: "APIå¼€å‘" },
                                        { name: "æ€§èƒ½ä¼˜åŒ–" }
                                    ]
                                },
                                {
                                    name: "æµ‹è¯•éƒ¨ç½²",
                                    children: [
                                        { name: "å•å…ƒæµ‹è¯•" },
                                        { name: "é›†æˆæµ‹è¯•" },
                                        { name: "ç”Ÿäº§éƒ¨ç½²" }
                                    ]
                                }
                            ]
                        },
                        {
                            name: "é¡¹ç›®ç»´æŠ¤",
                            children: [
                                { name: "Bugä¿®å¤" },
                                { name: "åŠŸèƒ½æ›´æ–°" },
                                { name: "æ€§èƒ½ç›‘æ§" }
                            ]
                        }
                    ]
                },
                {
                    name: "å­¦ä¹ è®¡åˆ’",
                    children: [
                        {
                            name: "ç¼–ç¨‹æŠ€èƒ½",
                            children: [
                                {
                                    name: "å‰ç«¯æŠ€æœ¯",
                                    children: [
                                        { name: "HTMLCSSåŸºç¡€" },
                                        { name: "JavaScripté«˜çº§ç¼–ç¨‹" },
                                        { name: "ReactVueæ¡†æ¶" }
                                    ]
                                },
                                {
                                    name: "åç«¯æŠ€æœ¯",
                                    children: [
                                        { name: "Node.jså¼€å‘" },
                                        { name: "æ•°æ®åº“è®¾è®¡" },
                                        { name: "ç³»ç»Ÿæ¶æ„è®¾è®¡" }
                                    ]
                                }
                            ]
                        },
                        {
                            name: "è½¯æŠ€èƒ½",
                            children: [
                                { name: "æ²Ÿé€šèƒ½åŠ›" },
                                { name: "å›¢é˜Ÿåä½œ" },
                                { name: "é¡¹ç›®ç®¡ç†æ–¹æ³•" },
                                { name: "æ—¶é—´ç®¡ç†æŠ€å·§" }
                            ]
                        }
                    ]
                }
            ]
        };

        let nodes = [];
        let links = [];
        let overlaps = [];

        // è°ƒè¯•æ—¥å¿—å‡½æ•°
        function addDebugLog(message, type = 'info') {
            const debugLog = document.getElementById('debug-log');
            const timestamp = new Date().toLocaleTimeString();
            const logItem = document.createElement('li');
            logItem.className = type;
            logItem.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            debugLog.appendChild(logItem);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }

        // å®Œå…¨å¤ç°æ’ä»¶çš„getNodeDimensionsæ–¹æ³•
        function getNodeDimensions(depth, text) {
            // åˆ›å»ºç¼“å­˜é”®
            const cacheKey = `${depth}-${text}-${text.length}`;

            // æ£€æŸ¥ç¼“å­˜
            if (textMeasurementCache.has(cacheKey)) {
                return textMeasurementCache.get(cacheKey);
            }

            const cleanedText = text.trim();
            let fontSize, fontWeight, maxWidth, minWidth, padding;

            if (depth === 0) {
                fontSize = "20px";
                fontWeight = "bold";
                maxWidth = null;
                minWidth = 120;
                padding = 24;
            } else if (depth === 1) {
                fontSize = "18px";
                fontWeight = "bold";
                maxWidth = null;
                minWidth = 110;
                padding = 20;
            } else {
                fontSize = "13px"; // ç´§å‡‘åŒ–ï¼šä»14pxå‡å°‘åˆ°13px
                fontWeight = "normal";
                maxWidth = null;
                minWidth = 70; // ä»80pxå‡å°‘åˆ°70px
                padding = 12; // ä»16pxå‡å°‘åˆ°12px (-25%)
            }

            const fontSizeNum = parseInt(fontSize);
            const textLength = cleanedText.length;

            // åŸºäºå®é™…æ–‡æœ¬æµ‹é‡ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œæ¨¡æ‹Ÿæ’ä»¶çš„æµ‹é‡é€»è¾‘ï¼‰
            const charWidth = fontSizeNum * 0.6; // ä¸­æ–‡å’Œè‹±æ–‡å­—ç¬¦çš„å¹³å‡å®½åº¦
            const textWidth = textLength * charWidth;

            // è®¡ç®—è¡Œæ•°ï¼ˆå‡è®¾ä¸æ¢è¡Œï¼‰
            const lines = [cleanedText];
            const textHeight = fontSizeNum * 1.2 * lines.length;

            // è®¡ç®—æœ€ç»ˆèŠ‚ç‚¹å°ºå¯¸
            const safetyBuffer = Math.max(8, textWidth * 0.05); // 5%ç¼“å†²æˆ–8pxæœ€å°
            const width = Math.max(textWidth + padding * 2 + safetyBuffer, minWidth);
            const height = Math.max(textHeight + padding * 2, fontSizeNum * 2.5);

            // è®¡ç®—æ–‡å­—ä½ç½®ï¼ˆå±…ä¸­å¯¹é½ï¼‰
            const textX = width / 2;
            const textY = height / 2;

            const result = {
                width,
                height,
                textX,
                textY,
                fontSize,
                fontWeight,
                lines,
                padding,
                minWidth,
                maxWidth
            };

            // ç¼“å­˜è®¡ç®—ç»“æœ
            textMeasurementCache.set(cacheKey, result);
            return result;
        }

        // å®Œå…¨å¤ç°æ’ä»¶çš„calculateDynamicSeparationæ–¹æ³•ï¼ˆæœ€æ–°ä¿®å¤ç‰ˆæœ¬ï¼‰
        function calculateDynamicSeparation(nodeA, nodeB) {
            const aDimensions = getNodeDimensions(nodeA.depth, nodeA.name);
            const bDimensions = getNodeDimensions(nodeB.depth, nodeB.name);

            const aHeight = aDimensions.height;
            const bHeight = bDimensions.height;
            const maxHeight = Math.max(aHeight, bHeight);

            // æ™ºèƒ½å‚ç›´é—´è·è®¡ç®—ï¼šåŸºäºå®é™…èŠ‚ç‚¹é«˜åº¦ + å®‰å…¨è¾¹ç•Œ
            const baseVerticalSpacing = layoutConfig.verticalSpacing;
            const baseMinGap = layoutConfig.minVerticalGap;

            // åŸºäºå®é™…èŠ‚ç‚¹é«˜åº¦çš„æ™ºèƒ½é—´è·
            const heightBasedVerticalGap = maxHeight + layoutConfig.nodeHeightBuffer + baseMinGap;
            const verticalGap = Math.max(heightBasedVerticalGap, baseVerticalSpacing);

            // åŸºäºåŸé—´è·ç³»ç»Ÿçš„ç›¸å¯¹è·ç¦»
            const baseSeparation = nodeA.parent === nodeB.parent ? 1 : 2;

            // ä¼˜åŒ–åçš„æ·±åº¦é—´è·è°ƒæ•´ï¼šé‡ç‚¹è§£å†³ç¬¬ä¸‰å±‚å’Œç¬¬å››å±‚é‡å 
            const siblingDepth = Math.max(nodeA.depth, nodeB.depth);
            let depthMultiplier = 1.0;

            if (siblingDepth === 0) {
                depthMultiplier = 1.0; // æ ¹èŠ‚ç‚¹ï¼šæ ‡å‡†é—´è·
            } else if (siblingDepth === 1) {
                depthMultiplier = 1.15; // ç¬¬1å±‚ï¼šç¨å¾®å¢åŠ 
            } else if (siblingDepth === 2) {
                depthMultiplier = 1.3; // ç¬¬2å±‚ï¼šé€‚åº¦å¢åŠ 
            } else if (siblingDepth === 3) {
                depthMultiplier = 1.8; // ç¬¬3å±‚ï¼šæ˜¾è‘—å¢åŠ 
            } else {
                depthMultiplier = 2.2 + (siblingDepth - 4) * 0.2; // ç¬¬4å±‚+ï¼šå¤§å¹…å¢åŠ 
            }

            // å¯¹äºåŒå±‚çº§å…„å¼ŸèŠ‚ç‚¹çš„ç‰¹æ®Šå¤„ç†ï¼ˆé’ˆå¯¹æ·±å±‚èŠ‚ç‚¹ä¼˜åŒ–ï¼‰
            if (nodeA.parent === nodeB.parent && nodeA.x !== nodeB.x) {
                const siblingVerticalGap = heightBasedVerticalGap * depthMultiplier;

                // ä¸ºæ·±å±‚å…„å¼ŸèŠ‚ç‚¹å¼ºåˆ¶æ›´å¤§çš„å®‰å…¨é—´è·
                let minimumSafeGap = 1.2;
                if (siblingDepth >= 4) {
                    minimumSafeGap = 2.5; // ç¬¬4å±‚+ï¼šå¼ºåˆ¶2.5å€é—´è·
                } else if (siblingDepth >= 3) {
                    minimumSafeGap = 2.0; // ç¬¬3å±‚ï¼šå¼ºåˆ¶2å€é—´è·
                }

                return Math.max(siblingVerticalGap / layoutConfig.verticalSpacing, minimumSafeGap);
            }

            return baseSeparation * depthMultiplier;
        }

        // åŠ¨æ€æ ‘é«˜åº¦è®¡ç®—ï¼ˆæœ€æ–°ä¿®å¤ç‰ˆæœ¬ï¼‰
        function calculateDynamicTreeHeight(root) {
            let maxDepth = 0;
            let nodesAtDepth = {};

            root.each(node => {
                maxDepth = Math.max(maxDepth, node.depth);
                if (!nodesAtDepth[node.depth]) {
                    nodesAtDepth[node.depth] = [];
                }
                nodesAtDepth[node.depth].push(node);
            });

            let totalHeight = 0;
            for (let depth = 0; depth <= maxDepth; depth++) {
                const nodes = nodesAtDepth[depth] || [];
                let layerHeight = 60; // åŸºç¡€å±‚é«˜

                // ç²¾ç»†åŒ–æ·±åº¦é—´è·è°ƒæ•´ï¼ˆåŒæ­¥ä¿®å¤ç¬¬ä¸‰å±‚å’Œç¬¬å››å±‚é‡å ï¼‰
                let depthMultiplier = 1.0;
                if (depth === 0) {
                    depthMultiplier = 0.8; // æ ¹èŠ‚ç‚¹ï¼šæ›´ç´§å‡‘
                } else if (depth === 1) {
                    depthMultiplier = 1.0; // ç¬¬1å±‚ï¼šæ ‡å‡†é—´è·
                } else if (depth === 2) {
                    depthMultiplier = 1.3; // ç¬¬2å±‚ï¼šé€‚åº¦å¢åŠ 
                } else if (depth === 3) {
                    depthMultiplier = 1.8; // ç¬¬3å±‚ï¼šæ˜¾è‘—å¢åŠ 
                } else {
                    depthMultiplier = 2.2 + (depth - 4) * 0.3; // ç¬¬4å±‚+ï¼šå¤§å¹…å¢åŠ 
                }

                const verticalSpacing = layoutConfig.verticalSpacing * depthMultiplier;

                // åŸºäºèŠ‚ç‚¹æ•°é‡çš„æ™ºèƒ½è°ƒæ•´ï¼ˆæ›´ä¿å®ˆçš„å¢é•¿ï¼‰
                const nodeCount = nodes.length;
                if (nodeCount > 3) {
                    const nodeCountMultiplier = 1 + (nodeCount - 3) * 0.1;
                    totalHeight += layerHeight + (verticalSpacing * nodeCountMultiplier);
                } else {
                    totalHeight += layerHeight + verticalSpacing;
                }
            }

            const minHeight = Math.max(totalHeight, layoutConfig.treeHeight);
            const depthBuffer = Math.max(100, maxDepth * 25);
            return minHeight + depthBuffer;
        }

        // æ¸²æŸ“æ€ç»´å¯¼å›¾
        function renderMindMap() {
            addDebugLog('ğŸ¨ å¼€å§‹æ¸²æŸ“æ€ç»´å¯¼å›¾...', 'info');

            const svg = d3.select("#mindmap");
            const contentGroup = d3.select("#content-group");
            const linkGroup = d3.select("#link-group");
            const nodeGroup = d3.select("#node-group");
            const overlapGroup = d3.select("#overlap-group");

            // æ¸…ç©ºç°æœ‰å†…å®¹
            contentGroup.selectAll("*").remove();
            linkGroup.selectAll("*").remove();
            nodeGroup.selectAll("*").remove();
            overlapGroup.selectAll("*").remove();

            // åˆ›å»ºå±‚æ¬¡ç»“æ„
            const root = d3.hierarchy(testData);

            // è®¡ç®—åŠ¨æ€æ ‘é«˜åº¦
            const dynamicTreeHeight = calculateDynamicTreeHeight(root);

            // åˆ›å»ºæ ‘å¸ƒå±€
            const treeLayout = d3.tree()
                .size([dynamicTreeHeight, layoutConfig.treeWidth])
                .separation((a, b) => calculateDynamicSeparation(a.data, b.data));

            const treeData = treeLayout(root);

            // å±…ä¸­åç§»
            const offsetX = 100;
            const offsetY = 50;

            // å­˜å‚¨èŠ‚ç‚¹æ•°æ®ç”¨äºé‡å æ£€æµ‹
            nodes = [];
            links = [];

            // æ¸²æŸ“è¿çº¿
            const linkElements = linkGroup.selectAll("path")
                .data(treeData.links())
                .enter()
                .append("path")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y + offsetX)
                    .y(d => d.x + offsetY))
                .attr("fill", "none")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 2);

            links = treeData.links().map(link => ({
                source: {
                    name: link.source.data.name,
                    depth: link.source.depth,
                    x: link.source.x + offsetY,
                    y: link.source.y + offsetX
                },
                target: {
                    name: link.target.data.name,
                    depth: link.target.depth,
                    x: link.target.x + offsetY,
                    y: link.target.y + offsetX
                }
            }));

            // æ¸²æŸ“èŠ‚ç‚¹
            const nodeElements = nodeGroup.selectAll("g")
                .data(treeData.descendants())
                .enter()
                .append("g")
                .attr("transform", d => {
                    const x = d.y + offsetX;
                    const y = d.x + offsetY;
                    const dimensions = getNodeDimensions(d.depth, d.data.name);

                    // è®°å½•èŠ‚ç‚¹æ•°æ®
                    const nodeInfo = {
                        name: d.data.name,
                        depth: d.depth,
                        x: y,
                        y: x,
                        width: dimensions.width,
                        height: dimensions.height
                    };
                    nodes.push(nodeInfo);

                    addDebugLog(`ğŸ“ Node "${d.data.name}" (L${d.depth}): ä½ç½®(${x.toFixed(1)}, ${y.toFixed(1)}) å°ºå¯¸${dimensions.width.toFixed(1)}Ã—${dimensions.height.toFixed(1)}`, 'info');

                    return `translate(${x}, ${y})`;
                });

            // æ·»åŠ èŠ‚ç‚¹çŸ©å½¢
            nodeElements.append("rect")
                .attr("class", d => `node-rect node-L${d.depth}`)
                .attr("width", d => getNodeDimensions(d.depth, d.data.name).width)
                .attr("height", d => getNodeDimensions(d.depth, d.data.name).height)
                .attr("x", 0)
                .attr("y", 0)
                .attr("rx", 6)
                .attr("ry", 6)
                .style("cursor", "pointer");

            // æ·»åŠ æ–‡æœ¬
            nodeElements.append("text")
                .attr("x", d => getNodeDimensions(d.depth, d.data.name).textX)
                .attr("y", d => getNodeDimensions(d.depth, d.data.name).textY)
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .style("font-size", d => getNodeDimensions(d.depth, d.data.name).fontSize)
                .style("font-weight", d => getNodeDimensions(d.depth, d.data.name).fontWeight)
                .style("fill", d => d.depth === 0 ? "#ffffff" : "#000000")
                .style("pointer-events", "none")
                .text(d => d.data.name);

            // æŒ‰å±‚çº§ç»Ÿè®¡
            const levelStats = {};
            nodes.forEach(node => {
                levelStats[node.depth] = (levelStats[node.depth] || 0) + 1;
            });

            addDebugLog(`âœ… æ¸²æŸ“å®Œæˆï¼š${nodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
            for (const [level, count] of Object.entries(levelStats)) {
                addDebugLog(`  L${level}: ${count} ä¸ªèŠ‚ç‚¹`, 'info');
            }

            showStatus(`æ€ç»´å¯¼å›¾æ¸²æŸ“å®Œæˆï¼Œå…± ${nodes.length} ä¸ªèŠ‚ç‚¹`, 'success');
        }

        // æ£€æµ‹å¹¶é«˜äº®é‡å 
        function detectAndHighlightOverlaps() {
            if (nodes.length === 0) {
                showStatus('è¯·å…ˆæ¸²æŸ“æ€ç»´å¯¼å›¾', 'error');
                return;
            }

            addDebugLog('ğŸ” å¼€å§‹æ£€æµ‹èŠ‚ç‚¹é‡å ...', 'info');
            overlaps = [];

            const overlapGroup = d3.select("#overlap-group");
            overlapGroup.selectAll("*").remove();

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];

                    // è·³è¿‡ç›´æ¥çˆ¶å­å…³ç³»
                    const isParentChild = checkParentChildRelationship(node1, node2);
                    if (isParentChild) {
                        continue;
                    }

                    // è®¡ç®—é‡å åŒºåŸŸ
                    const overlapLeft = Math.max(node1.x, node2.x);
                    const overlapTop = Math.max(node1.y, node2.y);
                    const overlapRight = Math.min(node1.x + node1.width, node2.x + node2.width);
                    const overlapBottom = Math.min(node1.y + node1.height, node2.y + node2.height);

                    const overlapWidth = Math.max(0, overlapRight - overlapLeft);
                    const overlapHeight = Math.max(0, overlapBottom - overlapTop);
                    const overlapArea = overlapWidth * overlapHeight;

                    if (overlapArea > 0) {
                        const overlapInfo = {
                            node1,
                            node2,
                            overlapArea,
                            overlapWidth,
                            overlapHeight,
                            x: overlapLeft,
                            y: overlapTop
                        };

                        overlaps.push(overlapInfo);

                        addDebugLog(`âŒ é‡å : ${node1.name} (L${node1.depth}) â†” ${node2.name} (L${node2.depth}) - é¢ç§¯: ${overlapArea.toFixed(1)}pxÂ² (${overlapWidth.toFixed(1)} Ã— ${overlapHeight.toFixed(1)})`, 'error');

                        // é«˜äº®é‡å åŒºåŸŸ
                        overlapGroup.append("rect")
                            .attr("class", "overlap-highlight")
                            .attr("x", overlapLeft)
                            .attr("y", overlapTop)
                            .attr("width", overlapWidth)
                            .attr("height", overlapHeight);
                    }
                }
            }

            if (overlaps.length === 0) {
                addDebugLog('âœ… æœªå‘ç°èŠ‚ç‚¹é‡å ï¼', 'success');
                showStatus('æœªå‘ç°èŠ‚ç‚¹é‡å ', 'success');
            } else {
                addDebugLog(`ğŸš¨ æ€»å…±å‘ç° ${overlaps.length} ä¸ªé‡å é—®é¢˜ï¼`, 'error');
                showStatus(`å‘ç° ${overlaps.length} ä¸ªé‡å é—®é¢˜`, 'error');
            }
        }

        // æ£€æŸ¥çˆ¶å­å…³ç³»
        function checkParentChildRelationship(node1, node2) {
            // ç®€åŒ–çš„çˆ¶å­å…³ç³»æ£€æŸ¥
            for (const link of links) {
                if ((link.source.name === node1.name && link.target.name === node2.name) ||
                    (link.source.name === node2.name && link.target.name === node1.name)) {
                    return true;
                }
            }
            return false;
        }

        // æ¸…ç©ºè°ƒè¯•ä¿¡æ¯
        function clearDebugInfo() {
            const debugLog = document.getElementById('debug-log');
            debugLog.innerHTML = '<li class="info">è°ƒè¯•ä¿¡æ¯å·²æ¸…ç©º</li>';
        }

        // å¯¼å‡ºè°ƒè¯•æ•°æ®
        function exportDebugData() {
            const debugData = {
                timestamp: new Date().toISOString(),
                layoutConfig: layoutConfig,
                nodes: nodes,
                links: links,
                overlaps: overlaps,
                statistics: {
                    totalNodes: nodes.length,
                    totalLinks: links.length,
                    totalOverlaps: overlaps.length,
                    nodeDepths: {}
                }
            };

            // ç»Ÿè®¡èŠ‚ç‚¹æ·±åº¦
            nodes.forEach(node => {
                debugData.statistics.nodeDepths[node.depth] = (debugData.statistics.nodeDepths[node.depth] || 0) + 1;
            });

            const dataStr = JSON.stringify(debugData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

            const exportLink = document.createElement('a');
            exportLink.setAttribute('href', dataUri);
            exportLink.setAttribute('download', `mindmap-debug-${Date.now()}.json`);
            document.body.appendChild(exportLink);
            exportLink.click();
            document.body.removeChild(exportLink);

            addDebugLog('ğŸ“Š è°ƒè¯•æ•°æ®å·²å¯¼å‡º', 'success');
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ¸²æŸ“
        window.addEventListener('load', () => {
            setTimeout(() => {
                renderMindMap();
                setTimeout(() => {
                    detectAndHighlightOverlaps();
                }, 500);
            }, 100);
        });
    </script>
</body>
</html>