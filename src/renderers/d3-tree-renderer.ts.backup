import { Notice } from 'obsidian';
import * as d3 from 'd3';
import { MindMapData, MindMapNode, EditingState, MindMapRenderer, NodeDimensions } from '../interfaces/mindmap-interfaces';
import { getFontSizeByDepth, STYLE_CONSTANTS, VALIDATION_CONSTANTS } from '../constants/mindmap-constants';
import { MindMapService } from '../services/mindmap-service';
import { LayoutCalculator } from './layout-calculator';
import { MindMapConfig } from '../config/types';
import { cleanTextContent } from '../utils/mindmap-utils';
import { CoordinateConverter } from '../utils/coordinate-system';
import { MindMapMessages } from '../i18n';
import { TextMeasurer } from '../utils/TextMeasurer';
import { NodeRenderer } from './core/NodeRenderer';
import { LinkRenderer } from './core/LinkRenderer';
import { TextRenderer } from './core/TextRenderer';
import { MouseInteraction } from '../interactions/MouseInteraction';
import { MouseInteractionCallbacks } from '../interactions/MouseInteractionCallbacks';
import { KeyboardManager } from '../interactions/KeyboardManager';
import { KeyboardHandlers, KeyboardManagerConfig } from '../interactions/KeyboardManagerCallbacks';

/**
 * D3æ ‘å½¢æ€ç»´å¯¼å›¾æ¸²æŸ“å™¨
 *
 * ã€èŒè´£ã€‘
 * å°†æ€ç»´å¯¼å›¾æ•°æ®æ¸²æŸ“ä¸ºå¯äº¤äº’çš„SVGå›¾å½¢ï¼Œå¤„ç†ç”¨æˆ·äº¤äº’å’ŒåŠ¨ç”»æ•ˆæœ
 *
 * ã€æ ¸å¿ƒåŠŸèƒ½ã€‘
 * 1. å¸ƒå±€æ¸²æŸ“ï¼šä½¿ç”¨ LayoutCalculator è®¡ç®—çš„åæ ‡æ¸²æŸ“èŠ‚ç‚¹å’Œè¿çº¿
 * 2. ç”¨æˆ·äº¤äº’ï¼šå¤„ç†ç‚¹å‡»ã€ç¼–è¾‘ã€æ‹–æ‹½ã€ç¼©æ”¾ç­‰ç”¨æˆ·æ“ä½œ
 * 3. èŠ‚ç‚¹ç®¡ç†ï¼šèŠ‚ç‚¹çš„å±•å¼€/æŠ˜å ã€ç¼–è¾‘ã€æ·»åŠ /åˆ é™¤
 * 4. è§†è§‰æ•ˆæœï¼šåŠ¨ç”»ã€ä¸»é¢˜é€‚é…ã€å“åº”å¼å¸ƒå±€
 * 5. æ€§èƒ½ä¼˜åŒ–ï¼šæ¸²æŸ“é”ã€ç¼“å­˜æœºåˆ¶ã€æŒ‰éœ€æ›´æ–°
 *
 *
 * ã€åæ ‡ç³»ç»Ÿã€‘âš ï¸âš ï¸âš ï¸ æå…¶é‡è¦ï¼
 *
 * æœ¬é¡¹ç›®ä½¿ç”¨**æ··åˆåæ ‡ç³»ç»Ÿ**ï¼Œè¿™æ˜¯ä¸ºäº†é¿å…èŠ‚ç‚¹é‡å å¹¶ä¿æŒå·¦å¯¹é½è€Œè®¾è®¡çš„ç‰¹æ®Šç³»ç»Ÿï¼š
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚                  æ··åˆåæ ‡ç³»ç»Ÿè¯´æ˜                        â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * 1. å¸ƒå±€åæ ‡ç³»ï¼ˆLayoutCalculator è®¡ç®—ï¼‰ï¼š
 *    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *    â”‚ d.x: å‚ç›´ä½ç½®ï¼ˆä»ä¸Šåˆ°ä¸‹å¢åŠ ï¼‰         â”‚
 *    â”‚      - è¡¨ç¤ºèŠ‚ç‚¹çš„ä¸­å¿ƒä½ç½®            â”‚
 *    â”‚      - ç”¨äºå‚ç›´å±…ä¸­è®¡ç®—              â”‚
 *    â”‚                                     â”‚
 *    â”‚ d.y: æ°´å¹³ä½ç½®ï¼ˆä»å·¦åˆ°å³å¢åŠ ï¼‰         â”‚
 *    â”‚      - è¡¨ç¤ºèŠ‚ç‚¹çš„å·¦è¾¹ç¼˜ä½ç½®          â”‚
 *    â”‚      - ç¡®ä¿å…„å¼ŸèŠ‚ç‚¹å·¦å¯¹é½            â”‚
 *    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * 2. ç”»å¸ƒåæ ‡ç³»ï¼ˆSVG/Canvas æ¸²æŸ“ï¼‰ï¼š
 *    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *    â”‚ x: æ°´å¹³ä½ç½®ï¼ˆä»å·¦åˆ°å³å¢åŠ ï¼‰          â”‚
 *    â”‚    - SVG çš„ç¬¬ä¸€ä¸ªåæ ‡               â”‚
 *    â”‚    - å¯¹åº”å¸ƒå±€çš„ d.yï¼ˆå·¦è¾¹ç¼˜ï¼‰       â”‚
 *    â”‚                                     â”‚
 *    â”‚ y: å‚ç›´ä½ç½®ï¼ˆä»ä¸Šåˆ°ä¸‹å¢åŠ ï¼‰          â”‚
 *    â”‚    - SVG çš„ç¬¬äºŒä¸ªåæ ‡               â”‚
 *    â”‚    - å¯¹åº”å¸ƒå±€çš„ d.xï¼ˆä¸­å¿ƒï¼‰è½¬æ¢     â”‚
 *    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * 3. åæ ‡è½¬æ¢å…¬å¼ï¼ˆåœ¨ transform ä¸­åº”ç”¨ï¼‰ï¼š
 *
 *    èŠ‚ç‚¹ç»„çš„ SVG transformï¼š
 *    ```
 *    transform = translate(
 *        x = d.y + offsetX,           // å¸ƒå±€çš„Y â†’ ç”»å¸ƒçš„Xï¼ˆå·¦è¾¹ç¼˜ï¼‰
 *        y = d.x + offsetY - height/2  // å¸ƒå±€çš„X â†’ ç”»å¸ƒçš„Yï¼ˆä¸­å¿ƒè½¬é¡¶è¾¹ï¼‰
 *    )
 *    ```
 *
 *    ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ
 *    - ä¿æŒ d.y ä½œä¸ºå·¦è¾¹ç¼˜ï¼šç¡®ä¿å…„å¼ŸèŠ‚ç‚¹å·¦å¯¹é½
 *    - å°† d.x ä»ä¸­å¿ƒè½¬æ¢ä¸ºé¡¶è¾¹ï¼šé€‚é… SVG rect ä» (0,0) ç»˜åˆ¶
 *    - ç»“æœï¼šå¸ƒå±€ç®€å•ï¼Œæ¸²æŸ“æ­£ç¡®
 *
 * 4. ç¤ºä¾‹ï¼š
 *
 *    å¸ƒå±€è®¡ç®—ï¼š
 *    ```
 *    çˆ¶èŠ‚ç‚¹: d.x=100, d.y=200
 *    â”œâ”€ å­èŠ‚ç‚¹A: d.x=50, d.y=400   (ä¸å­èŠ‚ç‚¹Bå·¦å¯¹é½)
 *    â””â”€ å­èŠ‚ç‚¹B: d.x=150, d.y=400  (ä¸å­èŠ‚ç‚¹Aå·¦å¯¹é½)
 *    ```
 *
 *    SVG transformï¼š
 *    ```
 *    çˆ¶èŠ‚ç‚¹: translate(200, 100-30) = translate(200, 70)
 *    â”œâ”€ å­èŠ‚ç‚¹A: translate(400, 50-20) = translate(400, 30)
 *    â””â”€ å­èŠ‚ç‚¹B: translate(400, 150-40) = translate(400, 110)
 *    ```
 *
 *    æ³¨æ„ï¼šå­èŠ‚ç‚¹Aå’ŒBçš„ X åæ ‡ç›¸åŒï¼ˆ400ï¼‰ï¼Œè¡¨ç¤ºå·¦å¯¹é½ï¼
 *
 *
 * ã€æ¸²æŸ“æµç¨‹ã€‘
 *
 * 1. æ•°æ®å‡†å¤‡ï¼š
 *    MindMapData â†’ D3.hierarchy() â†’ å±‚çº§ç»“æ„
 *
 * 2. å¸ƒå±€è®¡ç®—ï¼š
 *    LayoutCalculator.createCustomTreeLayout()
 *    â†’ æ¯ä¸ªèŠ‚ç‚¹è·å¾— (d.x, d.y) åæ ‡
 *
 * 3. SVGæ¸²æŸ“ï¼š
 *    render() â†’ createSVG() â†’ renderNodes() â†’ renderLinks()
 *    â†’ åº”ç”¨åæ ‡è½¬æ¢ï¼ˆæ··åˆç³»ç»Ÿï¼‰
 *
 * 4. äº¤äº’å¤„ç†ï¼š
 *    äº‹ä»¶ç›‘å¬ â†’ çŠ¶æ€æ›´æ–° â†’ é€‰æ‹©æ€§é‡æ–°æ¸²æŸ“
 *
 *
 * ã€æ¶æ„è®¾è®¡ã€‘
 *
 * æœ¬ç±»é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚  ç”¨æˆ·äº¤äº’å±‚ï¼ˆç‚¹å‡»ã€ç¼–è¾‘ã€æ‹–æ‹½ï¼‰      â”‚
 * â”‚  - äº‹ä»¶å¤„ç†å™¨                       â”‚
 * â”‚  - çŠ¶æ€ç®¡ç†                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *             â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚  ä¸šåŠ¡é€»è¾‘å±‚ï¼ˆMindMapServiceï¼‰        â”‚
 * â”‚  - èŠ‚ç‚¹æ“ä½œ                         â”‚
 * â”‚  - æ•°æ®æŒä¹…åŒ–                       â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *             â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚  æ¸²æŸ“å±‚ï¼ˆD3TreeRendererï¼‰           â”‚
 * â”‚  - SVGæ“ä½œ                          â”‚
 * â”‚  - åŠ¨ç”»æ•ˆæœ                         â”‚
 * â”‚  - åæ ‡è½¬æ¢                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *             â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚  å¸ƒå±€å±‚ï¼ˆLayoutCalculatorï¼‰         â”‚
 * â”‚  - åæ ‡è®¡ç®—                         â”‚
 * â”‚  - å°ºå¯¸èšåˆ                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *
 * ã€æ€§èƒ½ä¼˜åŒ–ã€‘
 *
 * 1. æ¸²æŸ“é”æœºåˆ¶ï¼š
 *    - é˜²æ­¢é‡å¤æ¸²æŸ“
 *    - æ‰¹é‡æ›´æ–°è¯·æ±‚
 *
 * 2. ç¼“å­˜æœºåˆ¶ï¼š
 *    - nodeDimensionsCache: èŠ‚ç‚¹å°ºå¯¸ç¼“å­˜
 *    - textMeasurementCache: æ–‡æœ¬æµ‹é‡ç¼“å­˜
 *
 * 3. é€‰æ‹©æ€§æ›´æ–°ï¼š
 *    - åªæ›´æ–°å˜åŒ–çš„èŠ‚ç‚¹
 *    - å¤ç”¨ä¸å˜çš„ SVG å…ƒç´ 
 *
 * 4. äº‹ä»¶å§”æ‰˜ï¼š
 *    - ä½¿ç”¨ D3 çš„æ•°æ®ç»‘å®š
 *    - æ‰¹é‡å¤„ç†äº‹ä»¶
 *
 *
 * ã€å¯è®¿é—®æ€§ã€‘
 *
 * - é”®ç›˜å¯¼èˆªæ”¯æŒ
 * - å±å¹•é˜…è¯»å™¨æ”¯æŒï¼ˆéƒ¨åˆ†ï¼‰
 * - å“åº”å¼è®¾è®¡
 * - ç§»åŠ¨ç«¯è§¦æ‘¸æ”¯æŒ
 *
 *
 * ã€ä¾èµ–å…³ç³»ã€‘
 *
 * - MindMapService: ä¸šåŠ¡é€»è¾‘æœåŠ¡
 * - LayoutCalculator: å¸ƒå±€è®¡ç®—å™¨
 * - D3.js: å¯è§†åŒ–åº“
 * - Obsidian API: æ’ä»¶é›†æˆ
 *
 *
 * ã€ä½¿ç”¨ç¤ºä¾‹ã€‘
 *
 * ```typescript
 * const renderer = new D3TreeRenderer(mindMapService, config);
 *
 * // æ¸²æŸ“æ€ç»´å¯¼å›¾
 * renderer.render(containerElement, mindMapData);
 *
 * // æ›´æ–°èŠ‚ç‚¹
 * renderer.updateNode(nodeId, newText);
 *
 * // é”€æ¯
 * renderer.destroy();
 * ```
 *
 *
 * ã€æ³¨æ„äº‹é¡¹ã€‘
 *
 * âš ï¸ åæ ‡ç³»ç»Ÿï¼šåŠ¡å¿…ç†è§£æ··åˆåæ ‡ç³»ç»Ÿå†ä¿®æ”¹åæ ‡ç›¸å…³ä»£ç 
 * âš ï¸ å†…å­˜ç®¡ç†ï¼šä½¿ç”¨å®Œæ¯•åè°ƒç”¨ destroy() é‡Šæ”¾èµ„æº
 * âš ï¸ çº¿ç¨‹å®‰å…¨ï¼šä¸æ”¯æŒå¹¶å‘æ¸²æŸ“ï¼Œä½¿ç”¨æ¸²æŸ“é”æœºåˆ¶
 * âš ï¸ äº‹ä»¶æ¸…ç†ï¼šé”€æ¯æ—¶å¿…é¡»ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
 *
 *
 * @see LayoutCalculator - å¸ƒå±€è®¡ç®—å™¨
 * @see MindMapService - ä¸šåŠ¡é€»è¾‘æœåŠ¡
 * @see MindMapData - æ•°æ®ç»“æ„
 */
export class D3TreeRenderer implements MindMapRenderer {
	private selectedNode: d3.HierarchyNode<MindMapNode> | null = null;
	private hoveredNode: d3.HierarchyNode<MindMapNode> | null = null;
	private editingState: EditingState = {
		isEditing: false,
		currentNode: null,
		originalText: '',
		editElement: null
	};
	private messages: MindMapMessages;

	constructor(private mindMapService: MindMapService, private config?: MindMapConfig, messages?: MindMapMessages) {
		// åˆå§‹åŒ–æ–‡æœ¬æµ‹é‡å™¨
		this.textMeasurer = new TextMeasurer();
		// åˆå§‹åŒ–å¸ƒå±€è®¡ç®—å™¨
		this.layoutCalculator = new LayoutCalculator();
		// åˆå§‹åŒ–èŠ‚ç‚¹æ¸²æŸ“å™¨
		this.nodeRenderer = new NodeRenderer(this.textMeasurer, this.layoutCalculator);
		// åˆå§‹åŒ–è¿çº¿æ¸²æŸ“å™¨
		this.linkRenderer = new LinkRenderer(this.textMeasurer, { lineOffset: this.layoutConfig.lineOffset });
		// åˆå§‹åŒ–æ–‡æœ¬æ¸²æŸ“å™¨
		this.textRenderer = new TextRenderer(this.textMeasurer, this.config, this.editingState);
		this.messages = messages || { errors: {}, notices: {}, ui: {}, validation: {} } as MindMapMessages;

		// åˆå§‹åŒ–é¼ æ ‡äº¤äº’å¤„ç†å™¨
		this.initializeMouseInteraction();

		// åˆå§‹åŒ–é”®ç›˜äº¤äº’å¤„ç†å™¨
		this.initializeKeyboardManager();
	}

	/**
	 * åˆå§‹åŒ–é¼ æ ‡äº¤äº’å¤„ç†å™¨
	 */
	private initializeMouseInteraction(): void {
		const callbacks: MouseInteractionCallbacks = {
			onNodeSelect: (node) => this.handleNodeSelectFromMouse(node),
			onNodeDoubleClick: (node, event) => this.handleNodeDoubleClickFromMouse(node, event),
			onNodeHover: (node) => {},  // æ‚¬åœé€»è¾‘å·²åœ¨ MouseInteraction ä¸­å¤„ç†
			onNodeLeave: (node) => {},   // ç¦»å¼€é€»è¾‘å·²åœ¨ MouseInteraction ä¸­å¤„ç†
			onCanvasClick: () => this.handleCanvasClickFromMouse(),
			onCanvasDrag: (dx, dy) => this.handleCanvasDragFromMouse(dx, dy),
			isCanvasInteractionEnabled: () => this.canvasInteractionEnabled
		};

		this.mouseInteraction = new MouseInteraction(callbacks);
	}

	// åŒå‡»æ£€æµ‹æœºåˆ¶ï¼ˆå·²åºŸå¼ƒï¼Œä½¿ç”¨ MouseInteractionï¼‰
	private clickTimeout: ReturnType<typeof setTimeout> | null = null;
	private lastClickTime = 0;
	private clickNode: d3.HierarchyNode<MindMapNode> | null = null;

	// ========== MouseInteraction å›è°ƒå¤„ç†æ–¹æ³• ==========

	/**
	 * å¤„ç†æ¥è‡ª MouseInteraction çš„èŠ‚ç‚¹é€‰æ‹©äº‹ä»¶
	 */
	private handleNodeSelectFromMouse(node: d3.HierarchyNode<MindMapNode>): void {
		// å…ˆæ¸…é™¤æ—§èŠ‚ç‚¹çš„ UIï¼ˆå¦‚æœå­˜åœ¨ä¸”ä¸æ˜¯å½“å‰èŠ‚ç‚¹ï¼‰
		if (this.selectedNode && this.selectedNode !== node) {
			const oldNodeElement = d3.selectAll(".node").filter((d: any) => d === this.selectedNode) as any;
			this.removePlusButton(oldNodeElement);
			this.removeAISuggestButton(oldNodeElement);

			// ç§»åŠ¨ç«¯ï¼šéšè—æ—§èŠ‚ç‚¹çš„å·¥å…·æ 
			if (this.config?.isMobile) {
				this.hideSharedToolbar();
			}
		}

		// æ›´æ–°å†…éƒ¨çŠ¶æ€
		this.selectedNode = node;

		// ä¸ºæ–°é€‰ä¸­çš„èŠ‚ç‚¹æ·»åŠ æŒ‰é’®
		const currentNodeElement = d3.selectAll(".nodes g")
			.filter((d: any) => d === node);
		const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);

		this.renderPlusButton(currentNodeElement as any, node, dimensions);
		this.renderAISuggestButton(currentNodeElement as any, node, dimensions);

		// ç§»åŠ¨ç«¯ï¼šæ˜¾ç¤ºå…±äº«å·¥å…·æ 
		if (this.config?.isMobile && !this.editingState.isEditing) {
			this.updateSharedToolbar(node, 0, 0);
		}
	}

	/**
	 * å¤„ç†æ¥è‡ª MouseInteraction çš„èŠ‚ç‚¹åŒå‡»äº‹ä»¶
	 */
	private handleNodeDoubleClickFromMouse(node: d3.HierarchyNode<MindMapNode>, event: MouseEvent): void {
		// ä½¿ç”¨çœŸå®çš„ MouseEvent è§¦å‘ç¼–è¾‘æ¨¡å¼
		this.triggerEdit(event, node);
	}

	/**
	 * å¤„ç†æ¥è‡ª MouseInteraction çš„ç”»å¸ƒç‚¹å‡»äº‹ä»¶
	 */
	private handleCanvasClickFromMouse(): void {
		// å¦‚æœæ­£åœ¨ç¼–è¾‘ï¼Œå…ˆä¿å­˜å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼
		if (this.editingState.isEditing) {
			this.saveNodeText();
			// saveNodeText ä¼šè°ƒç”¨ exitEditModeï¼Œæ¸…ç†UIå¹¶æ¢å¤ canvasInteractionEnabled
		}

		// æ¸…é™¤é€‰ä¸­çŠ¶æ€ï¼ˆåŒ…æ‹¬ç§»é™¤æŒ‰é’®ã€å·¥å…·æ ç­‰ï¼‰
		this.clearSelection();
	}

	/**
	 * å¤„ç†æ¥è‡ª MouseInteraction çš„ç”»å¸ƒæ‹–æ‹½äº‹ä»¶
	 */
	private handleCanvasDragFromMouse(dx: number, dy: number): void {
		if (!this.currentSvg) return;

		// æ›´æ–°ç”»å¸ƒä½ç½®
		const currentTransform = d3.zoomIdentity.translate(dx, dy);
		this.currentSvg.select(".mind-map-content").attr("transform", currentTransform as any);
	}

	/**
	 * åˆå§‹åŒ–é”®ç›˜äº¤äº’å¤„ç†å™¨
	 */
	private initializeKeyboardManager(): void {
		const config: KeyboardManagerConfig = {
			config: this.config,
			isEditing: () => this.editingState.isEditing,
			getSelectedNode: () => this.selectedNode
		};

		const handlers: KeyboardHandlers = {
			onTab: (node) => this.handleTabKeyFromManager(node),
			onDelete: (node) => this.handleDeleteKeyFromManager(node),
			onEnter: (node) => this.handleEnterKeyFromManager(node),
			onCopy: (node) => this.handleCopyFromManager(node),
			onCut: (node) => this.handleCutFromManager(node),
			onPaste: (node) => this.handlePasteFromManager(node)
		};

		this.keyboardManager = new KeyboardManager(config, handlers);
	}

	// ========== KeyboardManager å›è°ƒå¤„ç†æ–¹æ³• ==========

	/**
	 * å¤„ç†æ¥è‡ª KeyboardManager çš„ Tab é”®äº‹ä»¶
	 */
	private handleTabKeyFromManager(node: d3.HierarchyNode<MindMapNode>): void {
		// è°ƒç”¨ä¸+å·æŒ‰é’®ç›¸åŒçš„é€»è¾‘
		this.handlePlusButtonClick(new MouseEvent('click') as any, node);
	}

	/**
	 * å¤„ç†æ¥è‡ª KeyboardManager çš„ Delete é”®äº‹ä»¶
	 */
	private handleDeleteKeyFromManager(node: d3.HierarchyNode<MindMapNode>): void {
		const nodeToDelete = node.data;

		// æ‰§è¡Œåˆ é™¤æ“ä½œï¼ˆæœåŠ¡å±‚ä¼šå¤„ç†æ ¹èŠ‚ç‚¹æ£€æŸ¥å¹¶æ˜¾ç¤ºé€šçŸ¥ï¼‰
		const deleteSuccess = this.mindMapService.deleteNode(nodeToDelete);

		if (deleteSuccess) {
			// æ¸…é™¤é€‰ä¸­çŠ¶æ€
			this.clearSelection();

			// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
			this.onDataUpdated?.();
		}
	}

	/**
	 * å¤„ç†æ¥è‡ª KeyboardManager çš„ Enter é”®äº‹ä»¶
	 */
	private handleEnterKeyFromManager(node: d3.HierarchyNode<MindMapNode>): void {
		// ä¿å­˜çˆ¶èŠ‚ç‚¹å¼•ç”¨ï¼ˆåœ¨æ¸…é™¤é€‰ä¸­çŠ¶æ€ä¹‹å‰ï¼‰
		const parentNode = node.parent;

		// 1. åˆ›å»ºæ–°çš„å…„å¼ŸèŠ‚ç‚¹
		const newNode = this.mindMapService.createSiblingNode(
			node.data,
			"New Node"
		);

		if (!newNode) return;

		// 2. æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
		this.clearSelection();

		// 3. é€‰ä¸­æ–°åˆ›å»ºçš„å…„å¼ŸèŠ‚ç‚¹
		newNode.selected = true;
		this.selectedNode = {
			data: newNode,
			depth: newNode.level,
			parent: parentNode,
			children: [] as d3.HierarchyNode<MindMapNode>[]
		} as d3.HierarchyNode<MindMapNode>;

		// 4. è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
		this.onDataUpdated?.();

		// 5. è‡ªåŠ¨è¿›å…¥ç¼–è¾‘æ¨¡å¼
		setTimeout(() => {
			this.editNewNode();
		}, 150);
	}

	/**
	 * å¤„ç†æ¥è‡ª KeyboardManager çš„å¤åˆ¶å¿«æ·é”®
	 */
	private handleCopyFromManager(node: d3.HierarchyNode<MindMapNode>): Promise<boolean> {
		// åºåˆ—åŒ–æ•´ä¸ªå­æ ‘ä¸ºmarkdownæ ¼å¼
		const markdown = this.mindMapService.serializeSubtreeToMarkdown(node.data);

		// ä½¿ç”¨ Clipboard API å¤åˆ¶æ–‡æœ¬åˆ°å‰ªè´´æ¿
		if (navigator.clipboard && window.isSecureContext) {
			return navigator.clipboard.writeText(markdown).then(() => {
				this.showCopySuccessNotice(this.messages.notices.nodeTextCopied);
				return true;
			}).catch((err) => {
				console.error('Failed to copy subtree: ', err);
				this.fallbackCopyTextToClipboard(markdown);
				return true;
			});
		} else {
			this.fallbackCopyTextToClipboard(markdown);
			return Promise.resolve(true);
		}
	}

	/**
	 * å¤„ç†æ¥è‡ª KeyboardManager çš„å‰ªåˆ‡å¿«æ·é”®
	 */
	private handleCutFromManager(node: d3.HierarchyNode<MindMapNode>): Promise<boolean> {
		// å…ˆæ‰§è¡Œå¤åˆ¶æ“ä½œ
		return this.handleCopyFromManager(node).then(() => {
			// ç„¶åæ‰§è¡Œåˆ é™¤æ“ä½œ
			this.handleDeleteKeyFromManager(node);
			return true;
		});
	}

	/**
	 * å¤„ç†æ¥è‡ª KeyboardManager çš„ç²˜è´´å¿«æ·é”®
	 */
	private handlePasteFromManager(node: d3.HierarchyNode<MindMapNode>): Promise<boolean> {
		// ä½¿ç”¨ Clipboard API è¯»å–
		if (navigator.clipboard && window.isSecureContext) {
			return navigator.clipboard.readText().then((clipboardText) => {
				if (!clipboardText || clipboardText.trim().length === 0) {
					return true;
				}

				const trimmedText = clipboardText.trim();
				const isMarkdownFormat = /^\s*[\*\-]/m.test(clipboardText);

				if (isMarkdownFormat) {
					// æ˜¯markdownæ ¼å¼ â†’ åˆ›å»ºå­æ ‘
					const subtreeRoot = this.mindMapService.createSubtreeFromMarkdown(
						clipboardText,
						node.data.level
					);

					if (subtreeRoot) {
						subtreeRoot.parent = node.data;
						node.data.children.push(subtreeRoot);

						this.clearSelection();

						subtreeRoot.selected = true;
						this.selectedNode = {
							data: subtreeRoot,
							depth: subtreeRoot.level,
							parent: node,
							children: [] as d3.HierarchyNode<MindMapNode>[]
						} as d3.HierarchyNode<MindMapNode>;

						this.onDataUpdated?.();
					}
				} else {
					// æ™®é€šæ–‡æœ¬ â†’ åˆ›å»ºå•ä¸ªå­èŠ‚ç‚¹
					const truncatedText = trimmedText.substring(0, 100);
					const childNode = this.mindMapService.createChildNode(node.data, truncatedText);

					this.clearSelection();

					childNode.selected = true;
					this.selectedNode = {
						data: childNode,
						depth: childNode.level,
						parent: node,
						children: [] as d3.HierarchyNode<MindMapNode>[]
					} as d3.HierarchyNode<MindMapNode>;

					this.onDataUpdated?.();
				}

				return true;
			}).catch((err) => {
				console.error('Failed to read clipboard: ', err);
				return true;
			});
		}

		return Promise.resolve(true);
	}

	// è§†å›¾çŠ¶æ€ä¿æŒ
	private currentZoomTransform: d3.ZoomTransform | null = null;
	private currentSvg: d3.Selection<SVGSVGElement, unknown, null, undefined> | null = null;
	private currentContent: d3.Selection<SVGGElement, unknown, null, undefined> | null = null;
	private currentZoom: d3.ZoomBehavior<Element, unknown> | null = null;

	// DOM å®¹å™¨å¼•ç”¨ï¼ˆç”¨äºæ’å…¥å»ºè®®é¢æ¿ç­‰ UI å…ƒç´ ï¼‰
	private container: Element | null = null;

	// ç”»å¸ƒäº¤äº’çŠ¶æ€ï¼ˆç¼–è¾‘æ¨¡å¼ä¸‹ç¦ç”¨ç”»å¸ƒæ‹–æ‹½/ç¼©æ”¾ï¼‰
	private canvasInteractionEnabled: boolean = true;

	// AI å»ºè®®é€‰æ‹©çŠ¶æ€è¿½è¸ªï¼ˆç”¨äºå¤šé€‰åŠŸèƒ½ï¼‰
	private selectedSuggestions: Set<string> = new Set();

	// AI å»ºè®®åŠ è½½æç¤ºï¼ˆç”¨äºæŒç»­æ˜¾ç¤ºåŠ è½½çŠ¶æ€ï¼‰
	private loadingNotice: Notice | null = null;

	// æ–‡æœ¬æµ‹é‡å™¨å®ä¾‹
	private textMeasurer: TextMeasurer;

	// æ¸²æŸ“é”æœºåˆ¶
	private isRendering = false;
	private pendingRenderRequest = false;

	// é”®ç›˜äº‹ä»¶ç›‘å¬å™¨
	private keyboardListener: ((event: KeyboardEvent) => void) | null = null;

	// å¸ƒå±€è®¡ç®—å™¨å®ä¾‹
	private layoutCalculator: LayoutCalculator;

	// èŠ‚ç‚¹æ¸²æŸ“å™¨å®ä¾‹
	private nodeRenderer: NodeRenderer;

	// è¿çº¿æ¸²æŸ“å™¨å®ä¾‹
	private linkRenderer: LinkRenderer;

	// æ–‡æœ¬æ¸²æŸ“å™¨å®ä¾‹
	private textRenderer: TextRenderer;

	// é¼ æ ‡äº¤äº’å¤„ç†å™¨å®ä¾‹
	private mouseInteraction: MouseInteraction;

	// é”®ç›˜äº¤äº’å¤„ç†å™¨å®ä¾‹
	private keyboardManager: KeyboardManager;

	// å…±äº«å·¥å…·æ ï¼ˆç§»åŠ¨ç«¯ä¸“ç”¨ï¼Œå…¨å±€å”¯ä¸€ï¼‰
	private sharedToolbar: d3.Selection<SVGGElement, unknown, null, undefined> | null = null;
	private sharedToolbarNode: d3.HierarchyNode<MindMapNode> | null = null;

	// å¸ƒå±€é…ç½®ç³»ç»Ÿï¼ˆç´§å‡‘ä¼˜åŒ–ï¼‰
	private layoutConfig = {
		minNodeGap: 25,           // æœ€å°èŠ‚ç‚¹é—´è·ï¼ˆä¿æŒä¸å˜ï¼‰
		lineOffset: 6,            // è¿çº¿ä¸èŠ‚ç‚¹è¾¹ç¼˜çš„å®‰å…¨è·ç¦»ï¼ˆ8â†’6ï¼Œå‡å°‘25%ï¼‰
		horizontalSpacing: 170,   // æ°´å¹³åŸºç¡€é—´è·ï¼ˆ220â†’170ï¼Œå‡å°‘23%ï¼‰
		verticalSpacing: 110,     // å‚ç›´åŸºç¡€é—´è·ï¼ˆä¿æŒä¸å˜ï¼‰
		minVerticalGap: 25,       // æœ€å°å‚ç›´é—´è·ï¼ˆä¿æŒä¸å˜ï¼‰
		treeHeight: 800,          // æ ‘é«˜åº¦ï¼ˆå°†æ”¹ä¸ºåŠ¨æ€è®¡ç®—ï¼‰
		treeWidth: 1200,          // æ ‘å®½åº¦ï¼ˆ1400â†’1200ï¼Œå‡å°‘14%ï¼‰
		nodeHeightBuffer: 15,     // èŠ‚ç‚¹é«˜åº¦ç¼“å†²ï¼ˆä¿æŒä¸å˜ï¼‰
	};

	/**
	 * è®¾ç½®å…¨å±€å¿«æ·é”®
	 */
	render(container: Element, data: MindMapData): void {
		// æ¸²æŸ“é”æœºåˆ¶ï¼Œé˜²æ­¢é‡å¤æ¸²æŸ“
		if (this.isRendering) {
			this.pendingRenderRequest = true;
			return;
		}

		this.isRendering = true;

		// ä¿å­˜å®¹å™¨å¼•ç”¨ï¼ˆç”¨äºæ’å…¥å»ºè®®é¢æ¿ç­‰ UI å…ƒç´ ï¼‰
		this.container = container;

		// æ¸…ç©ºå®¹å™¨ä½†ä¿æŒCSSæ ·å¼ç¨³å®š
		container.empty();

		if (!data.rootNode) {
			this.isRendering = false;
			return;
		}

		// 1. åˆ›å»ºåŸºç¡€SVGå®¹å™¨ - æ›´å¤§å°ºå¯¸ä»¥æ˜¾ç¤ºå…¨éƒ¨å†…å®¹
		const svg = d3.select(container)
			.append("svg")
			.attr("width", 1600)
			.attr("height", 1000)
			.style("background", "#ffffff")
			.style("cursor", "grab");

		// 2. æ•°æ®å‡†å¤‡ - è½¬æ¢ä¸ºD3å±‚æ¬¡ç»“æ„
		const root = d3.hierarchy(data.rootNode);

		// 3. è‡ªå®šä¹‰æ ‘å½¢å¸ƒå±€ - æ¯ä¸ªå­èŠ‚ç‚¹åŸºäºçˆ¶èŠ‚ç‚¹ç‹¬ç«‹å®šä½
		const dynamicTreeHeight = this.calculateDynamicTreeHeight(root);

		// æ›´æ–°LayoutCalculatorçš„é…ç½®ï¼Œä½¿ç”¨åŠ¨æ€è®¡ç®—çš„é«˜åº¦
		this.layoutCalculator.updateConfig({
			treeHeight: dynamicTreeHeight
		});

		// ä½¿ç”¨è‡ªå®šä¹‰å¸ƒå±€å‡½æ•°ï¼Œå…è®¸æ¯ä¸ªå­èŠ‚ç‚¹åŸºäºå…¶çˆ¶èŠ‚ç‚¹å®½åº¦ç‹¬ç«‹å®šä½
		this.layoutCalculator.createCustomTreeLayout(root, (depth, text) =>
			this.textMeasurer.getNodeDimensions(depth, text)
		);

		// ä¿æŒå‚ç›´å¸ƒå±€è®¡ç®—ï¼Œä½†ç§»é™¤å›ºå®šå®½åº¦é™åˆ¶
		const treeData = root; // rootç°åœ¨å·²ç»é€šè¿‡è‡ªå®šä¹‰å¸ƒå±€æ›´æ–°äº†åæ ‡

		// 4. å±…ä¸­åç§»
		const offsetX = (1600 - 1600) / 2;  // æ°´å¹³å±…ä¸­åç§»
		const offsetY = (1000 - 1000) / 2; // å‚ç›´å±…ä¸­åç§»

		// 5. åˆ›å»ºSVGæ¸å˜å®šä¹‰
		this.createGradientDefinitions(svg);

	// 6. åˆ›å»ºå†…å®¹ç»„å’Œç¼©æ”¾åŠŸèƒ½
	const content = svg.append("g").attr("class", "mind-map-content");
	const zoom = d3.zoom()
		.scaleExtent([0.5, 3])  // ç¼©æ”¾èŒƒå›´ï¼š0.5å€åˆ°3å€
		.filter((event) => {
			// ç¼–è¾‘æ¨¡å¼ä¸‹ç¦ç”¨ zoomï¼ˆé™¤äº†åŒå‡»ï¼‰ï¼Œå…è®¸æ–‡æœ¬é€‰æ‹©
			return !(event.type === 'dblclick' || !this.canvasInteractionEnabled);
		})
		.on("zoom", (event) => {
			// Type assertion: D3 accepts ZoomTransform for attr("transform", ...)
			content.attr("transform", event.transform as any);
			// ä¿å­˜å½“å‰çš„ç¼©æ”¾å˜æ¢çŠ¶æ€
			this.currentZoomTransform = event.transform;
		});

	// ä¿å­˜å½“å‰è§†å›¾å¯¹è±¡å¼•ç”¨
	this.currentSvg = svg;
	this.currentContent = content;
	this.currentZoom = zoom;

	// åº”ç”¨zoomè¡Œä¸ºï¼Œä½†å¦‚æœæœ‰å·²ä¿å­˜çš„è§†å›¾çŠ¶æ€ï¼Œåˆ™ä¸è¦ç«‹å³é‡ç½®
	svg.call(zoom);

	// ç§»é™¤ D3 zoom çš„åŒå‡»ç¼©æ”¾ç›‘å¬å™¨ï¼ˆå®˜æ–¹æ–¹æ³•ï¼‰
	svg.on("dblclick.zoom", null);

	// å¦‚æœæœ‰å·²ä¿å­˜çš„è§†å›¾çŠ¶æ€ï¼Œç«‹å³åº”ç”¨å®ƒä»¥é¿å…è§†è§‰è·³è·ƒ
	if (this.currentZoomTransform) {
		svg.call(zoom.transform, this.currentZoomTransform);
		// Type assertion: D3 accepts ZoomTransform for attr("transform", ...)
		content.attr("transform", this.currentZoomTransform as any);
	}

	// 7. æ¸²æŸ“æ‰€æœ‰è¿çº¿ï¼ˆä½¿ç”¨LinkRendererï¼‰
	this.linkRenderer.renderLinks(content, treeData.links(), offsetX, offsetY);

	// 8. æ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹ï¼ˆä½¿ç”¨NodeRendereræ¸²æŸ“çŸ©å½¢ï¼Œç„¶åé™„åŠ æ–‡æœ¬å’Œäº‹ä»¶ï¼‰
	const nodeElements = this.nodeRenderer.renderNodes(content, treeData.descendants(), offsetX, offsetY);

	// 8.2. ä½¿ç”¨TextRendereræ¸²æŸ“æ–‡æœ¬å†…å®¹
	this.textRenderer.renderText(nodeElements, undefined, this);

	// 8.3. ä½¿ç”¨ MouseInteraction é™„åŠ é¼ æ ‡äº‹ä»¶å¤„ç†å™¨
	this.mouseInteraction.attachNodeClickHandlers(nodeElements);
	this.mouseInteraction.attachNodeHoverHandlers(nodeElements);

	// 8.4. æ¸²æŸ“é€‰ä¸­èŠ‚ç‚¹çš„+å·æŒ‰é’®
	this.renderPlusButtons(nodeElements);

	// 8.5. åˆ›å»ºå…±äº«å·¥å…·æ ï¼ˆç§»åŠ¨ç«¯ä¸“ç”¨ï¼Œåœ¨æ‰€æœ‰èŠ‚ç‚¹ä¹‹åæ¸²æŸ“ä»¥ç¡®ä¿åœ¨æœ€ä¸Šå±‚ï¼‰
	if (this.config?.isMobile) {
		this.initializeSharedToolbar(content);
	}

	// 9. æ¢å¤ä¹‹å‰çš„è§†å›¾çŠ¶æ€ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
	this.restoreViewState();

	// 10. åº”ç”¨åˆå§‹è§†å›¾ä½ç½®ï¼ˆä»…åœ¨é¦–æ¬¡æ¸²æŸ“ä¸”æ²¡æœ‰å·²ä¿å­˜çŠ¶æ€æ—¶ï¼‰
	this.applyInitialViewPosition(root, svg, zoom, container, offsetX, offsetY);

	// 11. ä½¿ç”¨ MouseInteraction æ·»åŠ ç”»å¸ƒç‚¹å‡»å’Œæ‹–æ‹½äº‹ä»¶
	this.mouseInteraction.attachCanvasClickHandler(svg);
	this.mouseInteraction.attachCanvasDragHandlers(svg);

	// 12. æ·»åŠ å…¨å±€é”®ç›˜äº‹ä»¶ç›‘å¬
	this.keyboardManager.attachGlobalListener();

	// 14. é‡Šæ”¾æ¸²æŸ“é”å¹¶å¤„ç†å¾…å¤„ç†çš„æ¸²æŸ“è¯·æ±‚
	this.isRendering = false;

	// å¦‚æœæœ‰å¾…å¤„ç†çš„æ¸²æŸ“è¯·æ±‚ï¼Œä½¿ç”¨å»¶è¿Ÿæ‰§è¡Œä»¥é¿å…é˜»å¡UI
	if (this.pendingRenderRequest) {
		this.pendingRenderRequest = false;
		setTimeout(() => {
			this.render(container, data);
		}, 16); // çº¦ä¸€å¸§çš„æ—¶é—´
	}

	// ğŸ”§ ä¿®å¤ï¼šé‡æ–°åŒæ­¥selectedNodeå¼•ç”¨ï¼Œç¡®ä¿å¼•ç”¨æ–°çš„D3å±‚çº§ç»“æ„
	this.syncSelectedNodeReference(root);

	// 15. æ¢å¤é€‰ä¸­èŠ‚ç‚¹çš„UIï¼ˆæŒ‰é’®ï¼‰
	this.restoreSelectionUI();
}

// é‡æ–°åŒæ­¥selectedNodeå¼•ç”¨ï¼Œç¡®ä¿æŒ‡å‘æ–°çš„D3å±‚çº§ç»“æ„
private syncSelectedNodeReference(root: d3.HierarchyNode<MindMapNode>): void {
	// å¦‚æœå½“å‰æ²¡æœ‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
	if (!this.selectedNode || !this.selectedNode.data) {
		return;
	}

	// éå†æ–°çš„D3å±‚çº§ç»“æ„ï¼Œæ‰¾åˆ°åŒ¹é…çš„èŠ‚ç‚¹
	const targetNode = this.selectedNode.data;
	let foundNode: d3.HierarchyNode<MindMapNode> | null = null;

	// ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æ‰¾åˆ°å…·æœ‰ç›¸åŒæ•°æ®å¼•ç”¨çš„èŠ‚ç‚¹
	root.each((d) => {
		if (d.data === targetNode) {
			foundNode = d;
		}
	});

	// å¦‚æœæ‰¾åˆ°äº†åŒ¹é…çš„èŠ‚ç‚¹ï¼Œæ›´æ–°selectedNodeå¼•ç”¨
	if (foundNode) {
		this.selectedNode = foundNode;
	} else {
		// å¦‚æœæ²¡æ‰¾åˆ°ï¼ˆèŠ‚ç‚¹å¯èƒ½è¢«åˆ é™¤ï¼‰ï¼Œæ¸…é™¤é€‰ä¸­çŠ¶æ€
		this.selectedNode = null;
	}
}

// æ¢å¤é€‰ä¸­èŠ‚ç‚¹çš„UIï¼ˆæŒ‰é’®ï¼‰
private restoreSelectionUI(): void {
	if (!this.currentSvg) return;

	// éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸ºé€‰ä¸­èŠ‚ç‚¹æ¢å¤æŒ‰é’®
	this.currentSvg.selectAll(".node")
		.each((d: any, i, nodes) => {
			if (d.data.selected) {
				const nodeElement = d3.select(nodes[i] as SVGGElement);
				const dimensions = this.textMeasurer.getNodeDimensions(d.depth, d.data.text);

				// é‡æ–°æ¸²æŸ“æŒ‰é’®ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
				this.renderPlusButton(nodeElement as any, d, dimensions);
				this.renderAISuggestButton(nodeElement as any, d, dimensions);
			}
		});
}

// ä¿å­˜å½“å‰è§†å›¾çŠ¶æ€
public saveViewState(): void {
	if (this.currentSvg && this.currentZoom) {
		// è·å–å½“å‰çš„ç¼©æ”¾å˜æ¢çŠ¶æ€
		const transform = d3.zoomTransform(this.currentSvg.node()!);
		this.currentZoomTransform = transform;
	}
}

// æ¢å¤è§†å›¾çŠ¶æ€
private restoreViewState(): void {
	if (this.currentZoomTransform && this.currentSvg && this.currentZoom) {
		// æ£€æŸ¥å½“å‰å˜æ¢æ˜¯å¦ä¸ä¿å­˜çš„å˜æ¢ä¸åŒï¼Œé¿å…é‡å¤åº”ç”¨
		const currentTransform = d3.zoomTransform(this.currentSvg.node()!);

		if (currentTransform.toString() !== this.currentZoomTransform.toString()) {
			// åº”ç”¨ä¹‹å‰ä¿å­˜çš„ç¼©æ”¾å˜æ¢
			this.currentSvg
				.call(this.currentZoom.transform, this.currentZoomTransform);

			// åŒæ—¶æ›´æ–°å†…å®¹ç»„çš„å˜æ¢
			if (this.currentContent) {
				// Type assertion: D3 accepts ZoomTransform for attr("transform", ...)
				this.currentContent.attr("transform", this.currentZoomTransform as any);
			}
		}
	}
}

// åº”ç”¨åˆå§‹è§†å›¾ä½ç½®ï¼ˆä»…åœ¨é¦–æ¬¡æ¸²æŸ“æ—¶ä½¿ç”¨ï¼‰
private applyInitialViewPosition(
	root: d3.HierarchyNode<MindMapNode>,
	svg: d3.Selection<SVGSVGElement, unknown, null, undefined>,
	zoom: d3.ZoomBehavior<any, unknown>,
	container: Element,
	offsetX: number,
	offsetY: number
): void {
	// å¦‚æœæœ‰å·²ä¿å­˜çš„è§†å›¾çŠ¶æ€ï¼Œä¸åº”ç”¨åˆå§‹ä½ç½®
	if (this.currentZoomTransform) {
		return;
	}

	// ç­‰å¾…ä¸‹ä¸€å¸§ä»¥ç¡®ä¿èŠ‚ç‚¹å·²å®Œå…¨æ¸²æŸ“
	requestAnimationFrame(() => {
		try {
			// è·å–æ ¹èŠ‚ç‚¹çš„ DOM å…ƒç´ å’Œè¾¹ç•Œæ¡†
			const nodeClassName = `node-${root.data.text.replace(/\s+/g, '-')}`;
			const rootGroup = svg.select(`g.${nodeClassName}`);
			const rootGroupNode = rootGroup.node() as SVGGElement;

			if (!rootGroupNode) {
				console.error('[InitialView] Root node element not found!');
				return;
			}

			// è·å–èŠ‚ç‚¹å°ºå¯¸ï¼ˆä½¿ç”¨ getBBox åªè·å–å®½é«˜ï¼‰
			const rootBBox = rootGroupNode.getBBox();

			if (!rootBBox || rootBBox.width === 0 || rootBBox.height === 0) {
				console.warn('[InitialView] Invalid root node bounding box');
				return;
			}

			// å…³é”®ä¿®å¤ï¼šè·å–èŠ‚ç‚¹çš„å®é™…ç”»å¸ƒåæ ‡ï¼ˆè€Œä¸æ˜¯ getBBox çš„å±€éƒ¨åæ ‡ï¼‰
			// èŠ‚ç‚¹ä½ç½®ç”±å¸ƒå±€è®¡ç®—å†³å®šï¼štransform = translate(root.y + offsetX, root.x + offsetY)
			const actualRootX = root.y + offsetX;  // èŠ‚ç‚¹çš„å®é™…Xä½ç½®ï¼ˆæ°´å¹³ï¼‰
			const actualRootY = root.x + offsetY;  // èŠ‚ç‚¹çš„å®é™…Yä½ç½®ï¼ˆå‚ç›´ï¼‰

			// è·å–å®¹å™¨å°ºå¯¸
			const containerWidth = container.clientWidth || 1600;
			const containerHeight = container.clientHeight || 1000;

			// è®¡ç®—ç›®æ ‡ä½ç½®
			const targetX = 20; // æ ¹èŠ‚ç‚¹å·¦è¾¹è·ç¦»ç”»é¢å·¦è¾¹20px
			const targetY = (containerHeight - rootBBox.height) / 2; // å‚ç›´å±…ä¸­

			// è®¡ç®—éœ€è¦çš„å¹³ç§»é‡ï¼ˆä½¿ç”¨å®é™…ç”»å¸ƒåæ ‡ï¼‰
			const translateX = targetX - actualRootX;
			const translateY = targetY - actualRootY;

			// åº”ç”¨åˆå§‹å˜æ¢ï¼ˆç¼©æ”¾1.0ï¼Œä»…å¹³ç§»ï¼‰
			const initialTransform = d3.zoomIdentity
				.translate(translateX, translateY)
				.scale(1);

			// åº”ç”¨å˜æ¢å¹¶ä¿å­˜çŠ¶æ€
			svg.call(zoom.transform, initialTransform);
			this.currentZoomTransform = initialTransform;
		} catch (error) {
			console.error('[InitialView] Error applying initial view position:', error);
		}
	});
}

destroy(): void {
	// æ¸…ç† DOM å®¹å™¨å¼•ç”¨
	this.container = null;

	// æ¸…ç†ç¼–è¾‘çŠ¶æ€
	this.exitEditMode();

	// æ¸…ç†é¼ æ ‡äº¤äº’å¤„ç†å™¨
	if (this.mouseInteraction) {
		this.mouseInteraction.destroy();
		this.mouseInteraction = null as any;
	}

	// æ¸…ç†é”®ç›˜äº¤äº’å¤„ç†å™¨
	if (this.keyboardManager) {
		this.keyboardManager.destroy();
		this.keyboardManager = null as any;
	}

	// æ¸…ç†ç‚¹å‡»è¶…æ—¶ï¼ˆå·²åºŸå¼ƒï¼Œä¿ç•™ä»¥é˜²ä¸‡ä¸€ï¼‰
	if (this.clickTimeout) {
		clearTimeout(this.clickTimeout);
		this.clickTimeout = null;
	}

	// æ¸…ç†æ‚¬åœçŠ¶æ€
	this.clearHoverState();

	// æ¸…ç†é€‰ä¸­çŠ¶æ€
	if (this.selectedNode) {
		this.selectedNode = null;
	}

	// æ¸…ç†è§†å›¾çŠ¶æ€
	this.currentZoomTransform = null;
	this.currentSvg = null;
	this.currentContent = null;
	this.currentZoom = null;

	// æ¸…ç† TextMeasurer
	if (this.textMeasurer) {
		this.textMeasurer.destroy();
		this.textMeasurer = null as any;
	}

	// æ¸…ç†å…±äº«å·¥å…·æ å¼•ç”¨
	this.sharedToolbar = null;
	this.sharedToolbarNode = null;

	// æ¸…ç† AI åŠ è½½æç¤ºï¼ˆå¦‚æœ renderer é”€æ¯æ—¶ AI è¿˜åœ¨è¯·æ±‚ï¼‰
	if (this.loadingNotice) {
		this.loadingNotice.hide();
		this.loadingNotice = null;
	}
}


// å¯ç”¨èŠ‚ç‚¹ç¼–è¾‘æ¨¡å¼
private enableNodeEditing(node: d3.HierarchyNode<MindMapNode>, editElement: HTMLDivElement): void {
	// æ£€æŸ¥æ˜¯å¦ä¸ºæ ¹èŠ‚ç‚¹ï¼ˆä¸­å¿ƒä¸»é¢˜ï¼‰ï¼Œä¸å…è®¸ç¼–è¾‘
	if (node.depth === 0) {
		this.showRootNodeEditWarning();
		return;
	}

	if (this.editingState.isEditing && this.editingState.currentNode !== node) {
		this.exitEditMode();
	}

	// ğŸ”§ ä¿®å¤ï¼šæ¸…é™¤ä¹‹å‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€ï¼ˆç¡®ä¿å•é€‰æœºåˆ¶ï¼‰
	if (this.selectedNode && this.selectedNode !== node) {
		// æ¸…é™¤æ—§èŠ‚ç‚¹çš„æ•°æ®å±‚é€‰ä¸­çŠ¶æ€
		this.selectedNode.data.selected = false;

		// æ¸…é™¤æ—§èŠ‚ç‚¹çš„è§†è§‰æ•ˆæœ
		d3.selectAll(".node-rect")
			.filter((d: any) => d === this.selectedNode)
			.classed("selected-rect", false);

		// ç§»é™¤æ—§èŠ‚ç‚¹çš„æŒ‰é’®
		const oldNodeElement = d3.selectAll(".node").filter((d: any) => d === this.selectedNode) as any;
		this.removePlusButton(oldNodeElement);
		this.removeAISuggestButton(oldNodeElement);

		// æ¸…ç©ºé€‰ä¸­èŠ‚ç‚¹å¼•ç”¨
		this.selectedNode = null;
	}

	// ç¦ç”¨ç”»å¸ƒäº¤äº’ï¼ˆæ‹–æ‹½ã€ç¼©æ”¾ï¼‰ï¼Œå…è®¸æ–‡æœ¬é€‰æ‹©å’Œç¼–è¾‘
	this.canvasInteractionEnabled = false;

	// è®¾ç½®ç¼–è¾‘çŠ¶æ€
	this.editingState = {
		isEditing: true,
		currentNode: node,
		originalText: node.data.text,
		editElement: editElement
	};

	try {
		// è®¾ç½®ä¸ºå¯ç¼–è¾‘
		editElement.contentEditable = "true";

		// æ·»åŠ ç¼–è¾‘æ ·å¼ç±»
		editElement.classList.add("editing");

		// æ·»åŠ èŠ‚ç‚¹ç¼–è¾‘çŠ¶æ€
		const nodeElement = d3.select(editElement.closest("g"));
		nodeElement.classed("node-editing", true);

		// ç§»åŠ¨ç«¯ï¼šè¿›å…¥ç¼–è¾‘æ¨¡å¼æ—¶éšè—å·¥å…·æ 
		if (this.config?.isMobile) {
			this.hideSharedToolbar();
		}

		// æ˜¾ç¤ºç¼–è¾‘æç¤º
		this.showEditingHint();

		// å…ˆè®¾ç½®æ­£ç¡®çš„æ ·å¼ï¼Œç¡®ä¿é¼ æ ‡äº‹ä»¶èƒ½æ­£å¸¸è§¦å‘
		editElement.style.userSelect = 'auto';
		editElement.style.cursor = 'text';
		editElement.style.pointerEvents = 'auto';

		// è®¾ç½®ç„¦ç‚¹å¹¶å…¨é€‰æ–‡æœ¬
		setTimeout(() => {
			try {
				editElement.focus();

				// å…¨é€‰æ–‡æœ¬
				const range = document.createRange();
				range.selectNodeContents(editElement);
				const selection = window.getSelection();
				if (selection) {
					selection.removeAllRanges();
					selection.addRange(range);
				}
			} catch (focusError) {
				console.error("MindMap Plugin: Error setting focus", focusError);
				this.showValidationError(this.messages.errors.focusSetFailed);
				this.exitEditMode();
			}
		}, 10);

	} catch (error) {
		console.error("MindMap Plugin: Error enabling edit mode", error);
		this.showValidationError(this.messages.errors.enterEditModeFailed);
		this.exitEditMode();
	}
}

// é€€å‡ºç¼–è¾‘æ¨¡å¼
public exitEditMode(): void {
	if (!this.editingState.isEditing) return;

	const { editElement, currentNode } = this.editingState;

	// æ¢å¤ç”»å¸ƒäº¤äº’
	this.canvasInteractionEnabled = true;

	if (editElement) {
		try {
			// è®¾ç½®ä¸ºä¸å¯ç¼–è¾‘
			editElement.contentEditable = "false";
			editElement.classList.remove("editing");

			// ğŸ”§ ä¿®å¤:æ¸…é™¤æ–‡æœ¬é€‰åŒº,é˜²æ­¢é€€å‡ºç¼–è¾‘åæ–‡æœ¬ä»ä¿æŒé€‰ä¸­çŠ¶æ€
			const selection = window.getSelection();
			if (selection) {
				selection.removeAllRanges();
			}

			// ç§»é™¤èŠ‚ç‚¹ç¼–è¾‘çŠ¶æ€
			const nodeElement = d3.select(editElement.closest("g"));
			nodeElement.classed("node-editing", false);

			// ğŸ”§ ä¿®å¤ï¼šé€€å‡ºç¼–è¾‘æ¨¡å¼æ—¶ä¿ç•™é€‰ä¸­çŠ¶æ€å’Œè§†è§‰æ•ˆæœ
			if (currentNode) {
				// ä¿æŒé€‰ä¸­çŠ¶æ€ï¼Œä¸æ¸…é™¤ selected
				// åˆ é™¤ï¼šcurrentNode.data.selected = false;

				// ä¿ç•™é€‰ä¸­è§†è§‰æ•ˆæœï¼ˆé«˜äº®è¾¹æ¡†ï¼‰
				// ä¸ç§»é™¤ selected-rect ç±»ï¼Œè®©é‡æ–°æ¸²æŸ“æ—¶è‡ªç„¶åº”ç”¨
				// åˆ é™¤ï¼šnodeRect.classed("selected-rect", false);

				// ä¸ç§»é™¤+å·æŒ‰é’®ï¼Œè®©é‡æ–°æ¸²æŸ“æ—¶è‡ªç„¶æ›´æ–°
				// åˆ é™¤ï¼šthis.removePlusButton(nodeElement);

				// ç§»åŠ¨ç«¯ï¼šéšè—å…±äº«å·¥å…·æ 
				if (this.config?.isMobile) {
					this.hideSharedToolbar();
				}
			}
		} catch (error) {
			console.error("MindMap Plugin: Error exiting edit mode", error);
		}
	}

	// éšè—ç¼–è¾‘æç¤º
	this.hideEditingHint();

	// ğŸ”§ ä¿®å¤ï¼šä¿æŒå½“å‰èŠ‚ç‚¹çš„é€‰ä¸­çŠ¶æ€
	if (currentNode) {
		// ç¡®ä¿selectedNodeæŒ‡å‘å½“å‰èŠ‚ç‚¹
		this.selectedNode = currentNode;
		// ä¿æŒ node.data.selected = true
		// è§†è§‰æ•ˆæœå’ŒæŒ‰é’®ä¿æŒæ˜¾ç¤º
	}

	// é‡ç½®ç¼–è¾‘çŠ¶æ€
	this.editingState = {
		isEditing: false,
		currentNode: null,
		originalText: '',
		editElement: null
	};
}

// å–æ¶ˆç¼–è¾‘æ¨¡å¼(æ¢å¤åŸå§‹æ–‡æœ¬,ä¸ä¿å­˜)
private cancelEditMode(): void {
	if (!this.editingState.isEditing) return;

	const { editElement } = this.editingState;

	// æ¢å¤åŸå§‹æ–‡æœ¬
	if (editElement && this.editingState.originalText) {
		editElement.textContent = this.editingState.originalText;
	}

	// è°ƒç”¨ exitEditMode è¿›è¡Œæ¸…ç†
	// ç”±äºæ–‡æœ¬å·²æ¢å¤,exitEditMode ä¸­çš„ä¿å­˜æ£€æŸ¥ä¼šè·³è¿‡(å› ä¸º currentText === originalText)
	this.exitEditMode();
}

// æ˜¾ç¤ºç¼–è¾‘æç¤º
private showEditingHint(): void {
	let hintElement = document.querySelector('.editing-hint') as HTMLElement;
	if (!hintElement) {
		hintElement = document.createElement('div');
		hintElement.className = 'editing-hint';
		// æ ¹æ®è®¾å¤‡ç±»å‹é€‰æ‹©ä¸åŒçš„æç¤ºæ–‡æ¡ˆ
		const editHint = this.config.isMobile
			? this.messages.ui.editHintMobile
			: this.messages.ui.editHintDesktop;
		hintElement.innerHTML = editHint;
		document.body.appendChild(hintElement);
	}
	hintElement.classList.add('show');
}

// éšè—ç¼–è¾‘æç¤º
private hideEditingHint(): void {
	const hintElement = document.querySelector('.editing-hint') as HTMLElement;
	if (hintElement) {
		hintElement.classList.remove('show');
	}
}

// ä¿å­˜èŠ‚ç‚¹æ–‡æœ¬
private saveNodeText(): void {
	if (!this.editingState.isEditing || !this.editingState.currentNode || !this.editingState.editElement) {
		return;
	}

	const { editElement, currentNode } = this.editingState;
	const newText = editElement.textContent?.trim() || '';

	try {
		// éªŒè¯æ–°æ–‡æœ¬
		if (!this.validateNodeText(newText)) {
			console.warn("MindMap Plugin: Invalid node text, discarding changes");
			this.showValidationError(this.messages.errors.nodeTextEmpty);
			return;
		}

		// æ£€æŸ¥æ–‡æœ¬æ˜¯å¦çœŸçš„æœ‰å˜åŒ–
		if (newText === this.editingState.originalText) {
			this.exitEditMode();
			return;
		}

		// æ›´æ–°æ•°æ®ç»“æ„
		const oldText = currentNode.data.text;
		currentNode.data.text = newText;

		// è§¦å‘æ–‡ä»¶ä¿å­˜ - æ–°æ¶æ„ä¸éœ€è¦é‡æ–°æ¸²æŸ“DOM
		this.onTextChanged?.(currentNode, newText);


	} catch (error) {
		console.error("MindMap Plugin: Error saving node text", error);
		this.showValidationError(this.messages.errors.saveFailed);
		// æ¢å¤åŸå§‹æ–‡æœ¬
		editElement.textContent = this.editingState.originalText;
	}

	this.exitEditMode();
}

// éªŒè¯èŠ‚ç‚¹æ–‡æœ¬
private validateNodeText(text: string): boolean {
	// æ£€æŸ¥æ˜¯å¦ä¸ºç©ºæˆ–åªæœ‰ç©ºç™½å­—ç¬¦
	if (!text || text.trim().length === 0) {
		return false;
	}

	// æ£€æŸ¥é•¿åº¦é™åˆ¶ï¼ˆé˜²æ­¢è¿‡é•¿çš„æ–‡æœ¬ï¼‰
	if (text.length > 200) {
		return false;
	}

	// æ£€æŸ¥æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦ï¼ˆä½¿ç”¨å¸¸é‡é…ç½®ï¼Œå…è®¸æ¢è¡Œç¬¦ï¼‰
	const invalidChars = VALIDATION_CONSTANTS.INVALID_CHARACTERS;
	if (invalidChars.some(char => text.includes(char))) {
		return false;
	}

	return true;
}

// æ˜¾ç¤ºéªŒè¯é”™è¯¯
private showValidationError(message: string): void {
	// åˆ›å»ºä¸´æ—¶çš„é”™è¯¯æç¤º
	const errorElement = document.createElement('div');
	errorElement.className = 'mind-map-validation-error';
	errorElement.textContent = message;
	errorElement.style.cssText = `
		position: fixed;
		top: 50px;
		right: 20px;
		background: var(--background-modifier-error);
		color: var(--color-red);
		border: 1px solid var(--color-red);
		border-radius: 6px;
		padding: 8px 12px;
		font-size: var(--font-ui-smaller);
		z-index: 1002;
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		transition: opacity 0.2s ease;
		max-width: 300px;
		word-wrap: break-word;
	`;

	document.body.appendChild(errorElement);

	// 3ç§’åè‡ªåŠ¨ç§»é™¤
	setTimeout(() => {
		errorElement.style.opacity = '0';
		setTimeout(() => {
			if (errorElement.parentNode) {
				errorElement.parentNode.removeChild(errorElement);
			}
		}, 200);
	}, 3000);

	// å¦‚æœå¤„äºç¼–è¾‘çŠ¶æ€ï¼Œå°è¯•æ¢å¤
	if (this.editingState.isEditing) {
		try {
			this.exitEditMode();
		} catch (recoveryError) {
			console.error("MindMap Plugin: Error during state recovery", recoveryError);
		}
	}
}

// æ˜¾ç¤ºæ ¹èŠ‚ç‚¹ç¼–è¾‘è­¦å‘Š
private showRootNodeEditWarning(): void {
	// ä½¿ç”¨ Obsidian çš„ Notice ç³»ç»Ÿ
	new Notice(this.messages.validation.cannotEditRoot, 3000);
}

// æ·»åŠ ç¼–è¾‘æˆåŠŸæç¤º
private showEditSuccess(message: string): void {
	const successElement = document.createElement('div');
	successElement.className = 'mind-map-success-message';
	successElement.textContent = message;
	successElement.style.cssText = `
		position: fixed;
		top: 50px;
		right: 20px;
		background: var(--background-modifier-success);
		color: var(--text-success);
		border: 1px solid var(--color-green);
		border-radius: 6px;
		padding: 8px 12px;
		font-size: var(--font-ui-smaller);
		z-index: 1002;
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		transition: opacity 0.2s ease;
		max-width: 300px;
		word-wrap: break-word;
	`;

	document.body.appendChild(successElement);

	// 2ç§’åè‡ªåŠ¨ç§»é™¤
	setTimeout(() => {
		successElement.style.opacity = '0';
		setTimeout(() => {
			if (successElement.parentNode) {
				successElement.parentNode.removeChild(successElement);
			}
		}, 200);
	}, 2000);
}

// æ›´æ–°å•ä¸ªèŠ‚ç‚¹çš„æ¸²æŸ“
private updateSingleNode(node: d3.HierarchyNode<MindMapNode>): void {
	const nodeElement = d3.select(`g.node-${node.data.text.replace(/\s+/g, '-')}`);
	if (!nodeElement.empty()) {
		const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);

		// æ›´æ–°çŸ©å½¢å°ºå¯¸
		nodeElement.select("rect")
			.attr("width", dimensions.width)
			.attr("height", dimensions.height);

		// æ›´æ–°æ–‡æœ¬å†…å®¹
		const textElement = nodeElement.select("text");
		textElement.selectAll("tspan").remove(); // æ¸…é™¤æ—§çš„tspan

		// é‡æ–°åˆ›å»ºæ–‡æœ¬è¡Œ
		const fontSizeNum = parseInt(dimensions.fontSize);
		const lineHeight = fontSizeNum * 1.2;
		const totalTextHeight = dimensions.lines.length * lineHeight;

		const isCenterAligned = node.depth === 0 || node.depth === 1;
		const textAnchor = isCenterAligned ? "middle" : "start";
		const textX = isCenterAligned ? dimensions.textX : dimensions.padding;

		let startY;
		if (dimensions.lines.length === 1) {
			startY = dimensions.textY;
		} else {
			startY = dimensions.textY - (totalTextHeight - fontSizeNum) / 2;
		}

		dimensions.lines.forEach((line, index) => {
			textElement.append("tspan")
				.attr("x", textX)
				.attr("y", startY + index * lineHeight)
				.attr("text-anchor", textAnchor)
				.text(line);
		});

		// æ›´æ–°foreignObjectå°ºå¯¸
		const foreignObject = nodeElement.select("foreignObject");
		if (!foreignObject.empty()) {
			foreignObject
				.attr("width", dimensions.width)
				.attr("height", dimensions.height);
		}
	}
}

// å¤„ç†èŠ‚ç‚¹ç¼–è¾‘äº‹ä»¶
private handleNodeEdit(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>, editElement: HTMLDivElement): void {
	// ä¸é˜»æ­¢äº‹ä»¶ä¼ æ’­ï¼Œå…è®¸æ­£å¸¸çš„é¼ æ ‡äº‹ä»¶ï¼ˆå…‰æ ‡å®šä½ã€æ–‡æœ¬é€‰æ‹©ç­‰ï¼‰

	// æ£€æŸ¥æ˜¯å¦ä¸ºæ ¹èŠ‚ç‚¹ï¼Œä¸å…è®¸ç¼–è¾‘
	if (node.depth === 0) {
		this.showRootNodeEditWarning();
		return;
	}

	// éªŒè¯editElement
	if (!editElement) {
		console.error("MindMap Plugin: Edit element is null or undefined");
		this.showValidationError("æ— æ³•æ‰¾åˆ°ç¼–è¾‘å…ƒç´ ");
		return;
	}

	// æ¸…é™¤æ‚¬åœçŠ¶æ€ï¼ˆç¼–è¾‘æ¨¡å¼ä¼˜å…ˆï¼‰
	const nodeElement = d3.select(editElement.closest("g"));
	const nodeRect = nodeElement.select(".node-rect");
	if (node.data.hovered && nodeRect) {
		this.clearNodeHoverState(node, nodeRect as any);
	}

	this.enableNodeEditing(node, editElement);
}

// æ–‡æœ¬å˜åŒ–å›è°ƒï¼ˆç”±MindMapViewè®¾ç½®ï¼‰
public onTextChanged?: (node: d3.HierarchyNode<MindMapNode>, newText: string) => void;

// æ•°æ®æ›´æ–°å›è°ƒï¼ˆç”±MindMapViewè®¾ç½®ï¼‰
public onDataUpdated?: () => void;

// ============================================================================
// ä»¥ä¸‹æ–¹æ³•å·²è¢« KeyboardManager æ›¿ä»£ï¼Œä¿ç•™ä½œä¸ºå‚è€ƒ
// ============================================================================

// æ·»åŠ å…¨å±€é”®ç›˜äº‹ä»¶ç›‘å¬ - å·²åºŸå¼ƒï¼Œä½¿ç”¨ KeyboardManager
/*
private addGlobalKeyboardListener(): void {
	// ç§»é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
	this.removeGlobalKeyboardListener();

	// æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
	this.keyboardListener = (event: KeyboardEvent) => {
		// ç¼–è¾‘æ¨¡å¼ä¸‹ï¼Œå…è®¸ Ctrl+V/Cmd+V ç²˜è´´æ“ä½œï¼Œå…¶ä»–å¿«æ·é”®ä¸å¤„ç†
		if (this.editingState.isEditing) {
			// åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ï¼Œåªå…è®¸ç²˜è´´æ“ä½œé€šè¿‡ï¼Œè®©æµè§ˆå™¨é»˜è®¤å¤„ç†
			if ((event.ctrlKey || event.metaKey) && event.key === "v") {
				return; // å…è®¸äº‹ä»¶ä¼ æ’­ï¼Œä½¿ç”¨æµè§ˆå™¨é»˜è®¤ç²˜è´´è¡Œä¸º
			}
			return; // é˜»æ­¢å…¶ä»–å¿«æ·é”®
		}

		if (event.key === "Tab") {
			event.preventDefault();
			this.handleTabKey();
		} else if (event.key === "Delete" || event.key === "Del") {
			event.preventDefault();
			this.handleDeleteKey();
		} else if (event.key === "Enter") {
			event.preventDefault();
			this.handleEnterKey();
		}
		// æ¡Œé¢ç«¯å¿«æ·é”®ï¼šCtrl+C / Cmd+C - å¤åˆ¶èŠ‚ç‚¹æ–‡æœ¬
		else if (!this.config?.isMobile && (event.ctrlKey || event.metaKey) && event.key === "c") {
			event.preventDefault();
			this.handleCopyShortcut();
		}
		// æ¡Œé¢ç«¯å¿«æ·é”®ï¼šCtrl+X / Cmd+X - å‰ªåˆ‡èŠ‚ç‚¹
		else if (!this.config?.isMobile && (event.ctrlKey || event.metaKey) && event.key === "x") {
			event.preventDefault();
			this.handleCutShortcut();
		}
		// æ¡Œé¢ç«¯å¿«æ·é”®ï¼šCtrl+V / Cmd+V - ç²˜è´´åˆ°èŠ‚ç‚¹
		else if (!this.config?.isMobile && (event.ctrlKey || event.metaKey) && event.key === "v") {
			event.preventDefault();
			this.handlePasteShortcut();
		}
	};

	document.addEventListener('keydown', this.keyboardListener);
}

// ç§»é™¤å…¨å±€é”®ç›˜äº‹ä»¶ç›‘å¬ - å·²åºŸå¼ƒï¼Œä½¿ç”¨ KeyboardManager
private removeGlobalKeyboardListener(): void {
	if (this.keyboardListener) {
		document.removeEventListener('keydown', this.keyboardListener);
		this.keyboardListener = null;
	}
}

// å¤„ç†Tabé”®äº‹ä»¶ - å·²åºŸå¼ƒï¼Œä½¿ç”¨ KeyboardManager
private handleTabKey(): void {
	if (this.selectedNode && this.selectedNode.data) {
		// è°ƒç”¨ä¸+å·æŒ‰é’®ç›¸åŒçš„é€»è¾‘
		this.handlePlusButtonClick(new MouseEvent('click') as any, this.selectedNode);
	}
}

// å¤„ç†Deleteé”®äº‹ä»¶ - å·²åºŸå¼ƒï¼Œä½¿ç”¨ KeyboardManager
private handleDeleteKey(): void {
	if (this.selectedNode && this.selectedNode.data) {
		const nodeToDelete = this.selectedNode.data;

	// ç¡®è®¤åˆ é™¤æ“ä½œï¼ˆå¯é€‰ï¼šå¯ä»¥æ·»åŠ ç¡®è®¤å¯¹è¯æ¡†ï¼‰
	// ä¸ºäº†ç®€åŒ–ä½“éªŒï¼Œç›´æ¥åˆ é™¤

	// æ‰§è¡Œåˆ é™¤æ“ä½œï¼ˆæœåŠ¡å±‚ä¼šå¤„ç†æ ¹èŠ‚ç‚¹æ£€æŸ¥å¹¶æ˜¾ç¤ºé€šçŸ¥ï¼‰
		const deleteSuccess = this.mindMapService.deleteNode(nodeToDelete);

		if (deleteSuccess) {
			// æ¸…é™¤é€‰ä¸­çŠ¶æ€
			this.selectedNode = null;

			// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
			this.onDataUpdated?.();
		}
		// æ³¨æ„ï¼šåˆ é™¤å¤±è´¥æ—¶ï¼ŒæœåŠ¡å±‚å·²ç»æ˜¾ç¤ºäº†ç›¸åº”çš„ Notice æç¤º
	}
}

// å¤„ç†Enteré”®äº‹ä»¶ - åˆ›å»ºå…„å¼ŸèŠ‚ç‚¹ - å·²åºŸå¼ƒï¼Œä½¿ç”¨ KeyboardManager
private handleEnterKey(): void {
	if (this.selectedNode && this.selectedNode.data) {
		// ä¸èƒ½ä¸ºæ ¹èŠ‚ç‚¹åˆ›å»ºå…„å¼ŸèŠ‚ç‚¹
		if (this.selectedNode.data.level === 0) {
			console.warn("Cannot create sibling for root node");
			return;
		}

		// ä¿å­˜çˆ¶èŠ‚ç‚¹å¼•ç”¨ï¼ˆåœ¨æ¸…é™¤é€‰ä¸­çŠ¶æ€ä¹‹å‰ï¼‰
		const parentNode = this.selectedNode.parent;

		// 1. åˆ›å»ºæ–°çš„å…„å¼ŸèŠ‚ç‚¹
		const newNode = this.mindMapService.createSiblingNode(
			this.selectedNode.data,
			"New Node"
		);

		if (!newNode) return;

		// 2. æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
		this.clearSelection();

		// 3. é€‰ä¸­æ–°åˆ›å»ºçš„å…„å¼ŸèŠ‚ç‚¹
		newNode.selected = true;
		this.selectedNode = {
			data: newNode,
			depth: newNode.level,
			parent: parentNode,
			children: [] as d3.HierarchyNode<MindMapNode>[]
		} as d3.HierarchyNode<MindMapNode>;

		// 4. è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
		this.onDataUpdated?.();

		// 5. è‡ªåŠ¨è¿›å…¥ç¼–è¾‘æ¨¡å¼
		setTimeout(() => {
			this.editNewNode();
		}, 150);
	}
}
*/


// æ·»åŠ æ‹–æ‹½äº¤äº’åŠŸèƒ½
private addDragInteraction(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>): void {
	let isDragging = false;
	let dragStartX = 0;
	let dragStartY = 0;
	let currentTransform = d3.zoomIdentity;

	svg.on("mousedown", (event: MouseEvent) => {
		// ç¼–è¾‘æ¨¡å¼ä¸‹ä¸å¯ç”¨ç”»å¸ƒæ‹–æ‹½ï¼Œå…è®¸æ–‡æœ¬é€‰æ‹©
		if (event.button === 0 && this.canvasInteractionEnabled) {
			isDragging = true;
			dragStartX = event.clientX;
			dragStartY = event.clientY;
			svg.style("cursor", "grabbing");
		}
	});

	svg.on("mousemove", (event: MouseEvent) => {
		if (isDragging && this.canvasInteractionEnabled) {
			const dx = event.clientX - dragStartX;
			const dy = event.clientY - dragStartY;

			// æ›´æ–°æ‹–æ‹½ä½ç½®
			currentTransform = d3.zoomIdentity.translate(dx, dy);
			// Type assertion: D3 accepts ZoomTransform for attr("transform", ...)
			svg.select(".mind-map-content").attr("transform", currentTransform as any);
		}
	});

	svg.on("mouseup", () => {
		if (this.canvasInteractionEnabled) {
			isDragging = false;
			svg.style("cursor", "grab");
		}
	});

	svg.on("mouseleave", () => {
		if (this.canvasInteractionEnabled) {
			isDragging = false;
			svg.style("cursor", "grab");
		}
	});
}


// åˆ›å»ºSVGæ¸å˜å®šä¹‰
private createGradientDefinitions(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>): void {
	const defs = svg.append("defs");

	// åˆ›å»ºä¸»è¦è¿çº¿æ¸å˜
	const linkGradient = defs.append("linearGradient")
		.attr("id", "linkGradient")
		.attr("x1", "0%")
		.attr("y1", "0%")
		.attr("x2", "100%")
		.attr("y2", "0%");

	linkGradient.append("stop")
		.attr("offset", "0%")
		.attr("stop-color", "var(--interactive-accent)")
		.attr("stop-opacity", 0.8);

	linkGradient.append("stop")
		.attr("offset", "50%")
		.attr("stop-color", "var(--interactive-accent-hover)")
		.attr("stop-opacity", 1);

	linkGradient.append("stop")
		.attr("offset", "100%")
		.attr("stop-color", "var(--text-accent)")
		.attr("stop-opacity", 0.6);
}

// è®¡ç®—åŠ¨æ€èŠ‚ç‚¹é—´è·
private calculateDynamicSeparation(a: d3.HierarchyNode<MindMapNode>, b: d3.HierarchyNode<MindMapNode>): number {
	const aDimensions = this.textMeasurer.getNodeDimensions(a.depth, a.data.text);
	const bDimensions = this.textMeasurer.getNodeDimensions(b.depth, b.data.text);

	// è®¡ç®—èŠ‚ç‚¹å®é™…å°ºå¯¸å½±å“çš„é—´è·
	const aHeight = aDimensions.height;
	const bHeight = bDimensions.height;
	const maxHeight = Math.max(aHeight, bHeight);

	// æ™ºèƒ½å‚ç›´é—´è·è®¡ç®—ï¼šåŸºäºå®é™…èŠ‚ç‚¹é«˜åº¦ + å®‰å…¨è¾¹ç•Œ
	const baseVerticalSpacing = this.layoutConfig.verticalSpacing;
	const baseMinGap = this.layoutConfig.minVerticalGap;

	// åŸºäºå®é™…èŠ‚ç‚¹é«˜åº¦çš„æ™ºèƒ½é—´è·
	const heightBasedVerticalGap = maxHeight + this.layoutConfig.nodeHeightBuffer + baseMinGap;
	const verticalGap = Math.max(heightBasedVerticalGap, baseVerticalSpacing);

	// åŸºäºåŸé—´è·ç³»ç»Ÿçš„ç›¸å¯¹è·ç¦»
	const baseSeparation = a.parent === b.parent ? 1 : 2;

	// ä¼˜åŒ–åçš„æ·±åº¦é—´è·è°ƒæ•´ï¼šé‡ç‚¹è§£å†³ç¬¬ä¸‰å±‚å’Œç¬¬å››å±‚é‡å 
	const siblingDepth = Math.max(a.depth, b.depth);
	let depthMultiplier = 1.0;

	if (siblingDepth === 0) {
		depthMultiplier = 1.0; // æ ¹èŠ‚ç‚¹ï¼šæ ‡å‡†é—´è·
	} else if (siblingDepth === 1) {
		depthMultiplier = 1.15; // ç¬¬1å±‚ï¼šç¨å¾®å¢åŠ 
	} else if (siblingDepth === 2) {
		depthMultiplier = 1.3; // ç¬¬2å±‚ï¼šé€‚åº¦å¢åŠ 
	} else if (siblingDepth === 3) {
		depthMultiplier = 1.8; // ç¬¬3å±‚ï¼šæ˜¾è‘—å¢åŠ 
	} else {
		depthMultiplier = 2.2 + (siblingDepth - 4) * 0.2; // ç¬¬4å±‚+ï¼šå¤§å¹…å¢åŠ 
	}

	// å¯¹äºåŒå±‚çº§å…„å¼ŸèŠ‚ç‚¹çš„ç‰¹æ®Šå¤„ç†
	if (a.parent === b.parent && a.x !== b.x) {
		// å…„å¼ŸèŠ‚ç‚¹çš„é—´è·è®¡ç®—ï¼ˆé’ˆå¯¹æ·±å±‚èŠ‚ç‚¹ä¼˜åŒ–ï¼‰
		const siblingVerticalGap = heightBasedVerticalGap * depthMultiplier;

		// ä¸ºæ·±å±‚å…„å¼ŸèŠ‚ç‚¹å¼ºåˆ¶æ›´å¤§çš„å®‰å…¨é—´è·
		let minimumSafeGap = 1.2;
		if (siblingDepth >= 4) {
			minimumSafeGap = 2.5; // ç¬¬4å±‚+ï¼šå¼ºåˆ¶2.5å€é—´è·
		} else if (siblingDepth >= 3) {
			minimumSafeGap = 2.0; // ç¬¬3å±‚ï¼šå¼ºåˆ¶2å€é—´è·
		}

		return Math.max(siblingVerticalGap / this.layoutConfig.verticalSpacing, minimumSafeGap);
	}

	// éå…„å¼ŸèŠ‚ç‚¹çš„é—´è·
	return baseSeparation * depthMultiplier;
}

// è®¡ç®—åŠ¨æ€æ ‘é«˜åº¦
private calculateDynamicTreeHeight(root: d3.HierarchyNode<MindMapNode>): number {
	let maxDepth = 0;
	let nodesAtDepth: { [key: number]: d3.HierarchyNode<MindMapNode>[] } = {};

	// ç»Ÿè®¡æ¯å±‚çš„èŠ‚ç‚¹å’Œæœ€å¤§æ·±åº¦
	root.each(node => {
		maxDepth = Math.max(maxDepth, node.depth);
		if (!nodesAtDepth[node.depth]) {
			nodesAtDepth[node.depth] = [];
		}
		nodesAtDepth[node.depth].push(node);
	});

	// è®¡ç®—æ¯å±‚æ‰€éœ€çš„é«˜åº¦ï¼Œä½¿ç”¨ä¼˜åŒ–çš„ç´§å‡‘å¸ƒå±€
	let totalHeight = 0;
	for (let depth = 0; depth <= maxDepth; depth++) {
		const nodes = nodesAtDepth[depth] || [];
		const layerHeight = this.calculateAdaptiveLayerHeight(nodes);

		// ç²¾ç»†åŒ–æ·±åº¦é—´è·è°ƒæ•´ï¼ˆåŒæ­¥ä¿®å¤ç¬¬ä¸‰å±‚å’Œç¬¬å››å±‚é‡å ï¼‰
		let depthMultiplier = 1.0;
		if (depth === 0) {
			depthMultiplier = 0.8; // æ ¹èŠ‚ç‚¹ï¼šæ›´ç´§å‡‘
		} else if (depth === 1) {
			depthMultiplier = 1.0; // ç¬¬1å±‚ï¼šæ ‡å‡†é—´è·
		} else if (depth === 2) {
			depthMultiplier = 1.3; // ç¬¬2å±‚ï¼šé€‚åº¦å¢åŠ 
		} else if (depth === 3) {
			depthMultiplier = 1.8; // ç¬¬3å±‚ï¼šæ˜¾è‘—å¢åŠ 
		} else {
			depthMultiplier = 2.2 + (depth - 4) * 0.3; // ç¬¬4å±‚+ï¼šå¤§å¹…å¢åŠ 
		}

		const verticalSpacing = this.layoutConfig.verticalSpacing * depthMultiplier;

		// åŸºäºèŠ‚ç‚¹æ•°é‡çš„æ™ºèƒ½è°ƒæ•´ï¼ˆæ›´ä¿å®ˆçš„å¢é•¿ï¼‰
		const nodeCount = nodes.length;
		if (nodeCount > 3) {
			const nodeCountMultiplier = 1 + (nodeCount - 3) * 0.1; // æ¯å¤šä¸€ä¸ªèŠ‚ç‚¹å¢åŠ 10%
			totalHeight += layerHeight + (verticalSpacing * nodeCountMultiplier);
		} else {
			totalHeight += layerHeight + verticalSpacing;
		}
	}

	// ç¡®ä¿ä¸å°äºåŸé«˜åº¦ï¼Œå¹¶æ·»åŠ é€‚å½“çš„ç¼“å†²ç©ºé—´
	const minHeight = Math.max(totalHeight, this.layoutConfig.treeHeight);
	const depthBuffer = Math.max(100, maxDepth * 25); // ä½¿ç”¨ç´§å‡‘çš„ç¼“å†²

	return minHeight + depthBuffer;
}

// è®¡ç®—åŠ¨æ€æ ‘å®½åº¦ï¼ˆåŸºäºè‡ªé€‚åº”æ°´å¹³é—´è·ï¼‰
private calculateDynamicTreeWidth(root: d3.HierarchyNode<MindMapNode>): number {
	let maxDepth = 0;
	let totalRequiredWidth = 0;
	let maxWidthPerDepth: { [key: number]: number } = {};

	// ç»Ÿè®¡æ¯å±‚çš„æœ€å¤§æ·±åº¦å’ŒèŠ‚ç‚¹ä¿¡æ¯
	root.each(node => {
		maxDepth = Math.max(maxDepth, node.depth);

		// è®¡ç®—èŠ‚ç‚¹å®½åº¦
		const nodeDimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);

		// è®°å½•æ¯å±‚çš„æœ€å¤§èŠ‚ç‚¹å®½åº¦
		if (!maxWidthPerDepth[node.depth] || nodeDimensions.width > maxWidthPerDepth[node.depth]) {
			maxWidthPerDepth[node.depth] = nodeDimensions.width;
		}
	});

	// ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œè®¡ç®—æ¯å±‚æ‰€éœ€çš„ç´¯è®¡å®½åº¦
	let currentWidth = 0;
	for (let depth = 0; depth <= maxDepth; depth++) {
		const currentLayerMaxWidth = maxWidthPerDepth[depth] || 100;

		if (depth === 0) {
			// æ ¹èŠ‚ç‚¹
			currentWidth = currentLayerMaxWidth;
		} else {
			// å­èŠ‚ç‚¹å±‚ï¼šåŸºäºçˆ¶èŠ‚ç‚¹å®½åº¦å’Œè‡ªé€‚åº”é—´è·è®¡ç®—
			const parentLayerMaxWidth = maxWidthPerDepth[depth - 1] || 100;

			// è®¡ç®—è‡ªé€‚åº”æ°´å¹³é—´è·
			const adaptiveSpacing = this.layoutCalculator.calculateAdaptiveHorizontalSpacing(
				parentLayerMaxWidth,
				currentLayerMaxWidth
			);

			// ç´¯è®¡å®½åº¦ = å‰ä¸€å±‚å®½åº¦ + è‡ªé€‚åº”é—´è· + å½“å±‚å®½åº¦
			currentWidth = currentWidth + adaptiveSpacing + currentLayerMaxWidth;
		}

		// æ›´æ–°æ€»å®½åº¦éœ€æ±‚
		totalRequiredWidth = Math.max(totalRequiredWidth, currentWidth);
	}

	// æ·»åŠ é€‚å½“çš„è¾¹è·ç¼“å†²
	const buffer = 100; // å·¦å³è¾¹è·å„50px
	const finalWidth = totalRequiredWidth + buffer;

	// ç¡®ä¿ä¸å°äºåŸé…ç½®çš„æœ€å°å®½åº¦
	const minWidth = Math.max(finalWidth, this.layoutConfig.treeWidth);

	return minWidth;
}

// è®¡ç®—æŒ‡å®šå±‚çº§çš„è‡ªé€‚åº”é«˜åº¦ï¼ˆåŸºäºå®é™…èŠ‚ç‚¹å°ºå¯¸ï¼‰
private calculateAdaptiveLayerHeight(nodes: d3.HierarchyNode<MindMapNode>[]): number {
	if (nodes.length === 0) return 60;

	// è®¡ç®—è¯¥å±‚æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§é«˜åº¦
	let maxHeight = 0;
	let totalTextLength = 0;

	nodes.forEach(node => {
		const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);
		maxHeight = Math.max(maxHeight, dimensions.height);
		totalTextLength += node.data.text.length;
	});

	// åŸºäºèŠ‚ç‚¹é«˜åº¦å’Œæ–‡æœ¬é•¿åº¦è®¡ç®—å±‚é«˜
	const textLengthBonus = Math.min(totalTextLength / nodes.length * 2, 50); // æ¯ä¸ªå­—ç¬¦2pxï¼Œæœ€å¤š50pxå¥–åŠ±
	const adaptiveHeight = maxHeight + textLengthBonus;

	// ç¡®ä¿æœ€å°é«˜åº¦
	const minHeight = nodes[0].depth === 0 ? 80 : nodes[0].depth === 1 ? 70 : 60;

	return Math.max(adaptiveHeight, minHeight);
}

// è®¡ç®—æŒ‡å®šå±‚çº§çš„å…¸å‹é«˜åº¦
private calculateLayerHeight(depth: number): number {
	// æ ¹æ®æ·±åº¦è®¡ç®—è¯¥å±‚èŠ‚ç‚¹çš„å…¸å‹é«˜åº¦
	const baseHeight = depth === 0 ? 60 : depth === 1 ? 50 : 45;
	const padding = this.nodeRenderer.getNodePadding(depth) * 2;
	return baseHeight + padding;
}

// ============================================================================
// ä»¥ä¸‹æ–¹æ³•å·²è¢« MouseInteraction æ›¿ä»£ï¼Œä¿ç•™ä½œä¸ºå‚è€ƒ
// ============================================================================

// å¤„ç†èŠ‚ç‚¹é€‰ä¸­çŠ¶æ€ï¼ˆå«åŒå‡»æ£€æµ‹ï¼‰- å·²åºŸå¼ƒï¼Œä½¿ç”¨ MouseInteraction
/*
private handleNodeSelection(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>, nodeRect: d3.Selection<SVGRectElement, unknown, null, undefined>): void {
	// ğŸ”§ ä¿®å¤:å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘å…¶ä»–èŠ‚ç‚¹ï¼Œå…ˆä¿å­˜ç¼–è¾‘å†…å®¹
	if (this.editingState.isEditing && this.editingState.currentNode !== node) {
		this.saveNodeText();  // ä¿å­˜ç¼–è¾‘å†…å®¹,è€Œä¸æ˜¯ç›´æ¥é€€å‡º
	}

	const currentTime = Date.now();
	const timeDiff = currentTime - this.lastClickTime;
	const isDoubleClick = timeDiff < 300 && this.clickNode === node; // 300mså†…çš„ç›¸åŒèŠ‚ç‚¹ç‚¹å‡»è§†ä¸ºåŒå‡»

	if (isDoubleClick) {
		this.lastClickTime = 0;
		this.clickNode = null;
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		// åŒå‡»æ—¶è§¦å‘ç¼–è¾‘
		this.triggerEdit(event, node);
		return;
	}

	// å•å‡»å¤„ç† - ç«‹å³åº”ç”¨é€‰æ‹©æ•ˆæœ
	this.lastClickTime = currentTime;
	this.clickNode = node;

	// æ¸…é™¤ä¹‹å‰çš„timeout
	if (this.clickTimeout) {
		clearTimeout(this.clickTimeout);
	}

	// ç«‹å³æ‰§è¡Œé€‰ä¸­é€»è¾‘ï¼Œä¸å»¶è¿Ÿ
	this.performNodeSelection(node, nodeRect);

	// è®¾ç½®timeoutç”¨äºåŒå‡»æ£€æµ‹çš„æ—¶é—´çª—å£ï¼Œä½†ä¸å½±å“è§†è§‰æ•ˆæœ
	this.clickTimeout = setTimeout(() => {
		this.lastClickTime = 0;
		this.clickNode = null;
		this.clickTimeout = null;
	}, 300);

	// é˜»æ­¢äº‹ä»¶å†’æ³¡
	event.stopPropagation();
}
*/

// æ‰§è¡Œå®é™…çš„èŠ‚ç‚¹é€‰æ‹©é€»è¾‘ - å·²åºŸå¼ƒï¼Œä½¿ç”¨ MouseInteraction
/*
private performNodeSelection(node: d3.HierarchyNode<MindMapNode>, nodeRect: d3.Selection<SVGRectElement, unknown, null, undefined>): void {
	// ğŸ”§ ä¿®å¤:å¦‚æœæ­£åœ¨ç¼–è¾‘,å…ˆä¿å­˜ç¼–è¾‘å†…å®¹
	if (this.editingState.isEditing) {
		this.saveNodeText();
		// saveNodeText ä¼šè°ƒç”¨ exitEditMode æ¸…ç†UI
	}

	// æ¸…é™¤ä¹‹å‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼ˆå¦‚æœå­˜åœ¨ä¸”ä¸æ˜¯å½“å‰èŠ‚ç‚¹ï¼‰
	if (this.selectedNode && this.selectedNode !== node) {
		this.selectedNode.data.selected = false;
		// æ›´æ–°ä¹‹å‰é€‰ä¸­èŠ‚ç‚¹çš„è§†è§‰çŠ¶æ€
		d3.selectAll(".node-rect")
			.filter((d: any) => d === this.selectedNode)
			.classed("selected-rect", false);

		// ç§»é™¤ä¹‹å‰é€‰ä¸­èŠ‚ç‚¹çš„+å·æŒ‰é’®
		const previousNodeElement = d3.selectAll(".nodes g")
			.filter((d: any) => d === this.selectedNode);
		this.removePlusButton(previousNodeElement as any);

		// ç§»é™¤ä¹‹å‰é€‰ä¸­èŠ‚ç‚¹çš„ AI å»ºè®®æŒ‰é’®
		this.removeAISuggestButton(previousNodeElement as any);

		// ç§»åŠ¨ç«¯ï¼šç§»é™¤ä¹‹å‰é€‰ä¸­èŠ‚ç‚¹çš„å·¥å…·æ 
		if (this.config?.isMobile) {
			this.hideSharedToolbar();
		}
	}

	// æ¸…é™¤å½“å‰èŠ‚ç‚¹çš„æ‚¬åœçŠ¶æ€ï¼ˆé€‰ä¸­çŠ¶æ€ä¼˜å…ˆçº§é«˜äºæ‚¬åœçŠ¶æ€ï¼‰
	if (node.data.hovered) {
		this.clearNodeHoverState(node, nodeRect);
	}

	// æ€»æ˜¯é€‰ä¸­ç‚¹å‡»çš„èŠ‚ç‚¹ï¼ˆä¸å†æ˜¯åˆ‡æ¢æ¨¡å¼ï¼‰
	node.data.selected = true;
	this.selectedNode = node;
	nodeRect.classed("selected-rect", true);

	// ä¸ºæ–°é€‰ä¸­çš„èŠ‚ç‚¹æ·»åŠ +å·æŒ‰é’®
	const currentNodeElement = d3.selectAll(".nodes g")
		.filter((d: any) => d === node);
	const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);
	this.renderPlusButton(currentNodeElement as any, node, dimensions);

	// ä¸ºæ–°é€‰ä¸­çš„èŠ‚ç‚¹æ·»åŠ  AI å»ºè®®æŒ‰é’®
	this.renderAISuggestButton(currentNodeElement as any, node, dimensions);

	// ç§»åŠ¨ç«¯ï¼šä¸ºæ–°é€‰ä¸­çš„èŠ‚ç‚¹æ˜¾ç¤ºå…±äº«å·¥å…·æ ï¼ˆç¼–è¾‘å’Œåˆ é™¤æŒ‰é’®ï¼‰
	// æ³¨æ„ï¼šå¦‚æœåœ¨ç¼–è¾‘æ¨¡å¼ä¸­ï¼Œä¸æ˜¾ç¤ºå·¥å…·æ ï¼ˆé¿å…åŒå‡»æ—¶å‡ºç°é‡å¤å·¥å…·æ ï¼‰
	if (this.config?.isMobile && !this.editingState.isEditing) {
		// ä½¿ç”¨å…±äº«å·¥å…·æ ï¼ŒoffsetX å’Œ offsetY åœ¨å½“å‰å®ç°ä¸­éƒ½æ˜¯ 0
		this.updateSharedToolbar(node, 0, 0);
	}
}
*/

// å¤„ç†èŠ‚ç‚¹æ‚¬åœäº‹ä»¶
private handleNodeHover(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>, nodeRect: d3.Selection<SVGRectElement, unknown, null, undefined>): void {
	// å¦‚æœèŠ‚ç‚¹å·²ç»æ˜¯é€‰ä¸­çŠ¶æ€ï¼Œä¸åº”ç”¨æ‚¬åœæ•ˆæœ
	if (node.data.selected) {
		return;
	}

	// æ¸…é™¤ä¹‹å‰çš„æ‚¬åœçŠ¶æ€
	if (this.hoveredNode && this.hoveredNode !== node) {
		this.clearHoverState();
	}

	// è®¾ç½®æ–°çš„æ‚¬åœçŠ¶æ€
	this.hoveredNode = node;
	node.data.hovered = true;

	// åº”ç”¨æ‚¬åœè§†è§‰æ•ˆæœï¼ˆç°è‰²è¾¹æ¡†ï¼‰
	nodeRect.classed("hovered-rect", true);
}

// å¤„ç†èŠ‚ç‚¹ç¦»å¼€äº‹ä»¶
private handleNodeLeave(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>, nodeRect: d3.Selection<SVGRectElement, unknown, null, undefined>): void {
	// å¦‚æœèŠ‚ç‚¹æ˜¯é€‰ä¸­çŠ¶æ€ï¼Œä¸æ¸…é™¤æ‚¬åœçŠ¶æ€ï¼ˆé€‰ä¸­çŠ¶æ€ä¼˜å…ˆçº§æ›´é«˜ï¼‰
	if (node.data.selected) {
		return;
	}

	// æ¸…é™¤æ‚¬åœçŠ¶æ€
	this.clearNodeHoverState(node, nodeRect);
}

// æ¸…é™¤å•ä¸ªèŠ‚ç‚¹çš„æ‚¬åœçŠ¶æ€
private clearNodeHoverState(node: d3.HierarchyNode<MindMapNode>, nodeRect: d3.Selection<SVGRectElement, unknown, null, undefined>): void {
	node.data.hovered = false;
	nodeRect.classed("hovered-rect", false);

	if (this.hoveredNode === node) {
		this.hoveredNode = null;
	}
}

// æ¸…é™¤æ‰€æœ‰æ‚¬åœçŠ¶æ€
private clearHoverState(): void {
	if (this.hoveredNode) {
		this.hoveredNode.data.hovered = false;
		// ç§»é™¤æ‰€æœ‰èŠ‚ç‚¹çš„æ‚¬åœè§†è§‰æ•ˆæœ
		d3.selectAll(".node-rect")
			.classed("hovered-rect", false);
		this.hoveredNode = null;
	}
}

// æ¸²æŸ“é€‰ä¸­èŠ‚ç‚¹çš„+å·æŒ‰é’®
private renderPlusButtons(nodeElements: d3.Selection<SVGGElement, d3.HierarchyNode<MindMapNode>, SVGGElement, unknown>): void {
	const self = this;

	// ä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ +å·æŒ‰é’®
	nodeElements.each(function(d) {
		const nodeElement = d3.select(this);
		const dimensions = self.textMeasurer.getNodeDimensions(d.depth, d.data.text);

		// åªä¸ºé€‰ä¸­çš„èŠ‚ç‚¹æ¸²æŸ“+å·æŒ‰é’®
		if (d.data.selected) {
			self.renderPlusButton(nodeElement as any, d, dimensions);
		}
	});
}

// æ¸²æŸ“å•ä¸ªèŠ‚ç‚¹çš„+å·æŒ‰é’®
private renderPlusButton(nodeElement: d3.Selection<SVGGElement, d3.HierarchyNode<MindMapNode>, any, any>,
						 node: d3.HierarchyNode<MindMapNode>,
						 dimensions: any): void {
	// æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨+å·æŒ‰é’®
	const existingButton = nodeElement.select(".plus-button-group");
	if (!existingButton.empty()) {
		return; // å·²å­˜åœ¨åˆ™ä¸é‡å¤åˆ›å»º
	}

	// è®¡ç®—ä¸¤ä¸ªæŒ‰é’®çš„æ€»é«˜åº¦ï¼ˆ+å·æŒ‰é’®20px + é—´è·10px + AIæŒ‰é’®20px = 50pxï¼‰
	const totalButtonsHeight = 20 + 10 + 20;
	// +å·æŒ‰é’®ä½äºä¸Šæ–¹ä½ç½®
	const buttonY = (dimensions.height - totalButtonsHeight) / 2;

	// åˆ›å»º+å·æŒ‰é’®ç»„
	const buttonGroup = nodeElement.append("g")
		.attr("class", "plus-button-group")
		.attr("transform", `translate(${dimensions.width + 4}, ${buttonY})`);

	// æ·»åŠ ç‚¹å‡»äº‹ä»¶å¤„ç†å™¨
	buttonGroup.on("click", (event: MouseEvent) => {
		this.handlePlusButtonClick(event, node);
	});

	// åˆ›å»ºåœ†å½¢èƒŒæ™¯
	buttonGroup.append("circle")
		.attr("class", "plus-button-bg")
		.attr("cx", 10)
		.attr("cy", 10)
		.attr("r", 10)
		.attr("fill", "#2972f4")  // è“è‰²èƒŒæ™¯
		.style("opacity", 0.9);

	// åˆ›å»º+å·æ–‡æœ¬ - ä¿®å¤å±…ä¸­å¯¹é½
	buttonGroup.append("text")
		.attr("class", "plus-button-text")
		.attr("x", 10)              // ä¸åœ†å½¢cxå¯¹é½
		.attr("y", 10)              // ä¿®å¤ï¼šä¸åœ†å½¢cyå¯¹é½
		.attr("text-anchor", "middle")
		.attr("dominant-baseline", "middle")
		.attr("fill", "white")
		.attr("font-size", "16px")
		.attr("font-weight", "bold")
		.style("pointer-events", "none")  // é˜»æ­¢æ–‡æœ¬äº‹ä»¶ï¼Œè®©åœ†å½¢èƒŒæ™¯æ¥æ”¶äº‹ä»¶
		.text("+");
}

// ç§»é™¤èŠ‚ç‚¹çš„+å·æŒ‰é’®
private removePlusButton(nodeElement: d3.Selection<SVGGElement, d3.HierarchyNode<MindMapNode>, any, any>): void {
	const buttonGroup = nodeElement.select(".plus-button-group");
	if (!buttonGroup.empty()) {
		buttonGroup.remove();
	}
}

// ========== AI å»ºè®®åŠŸèƒ½ ==========

/**
 * æ¸²æŸ“ AI å»ºè®®æŒ‰é’®
 */
private renderAISuggestButton(nodeElement: d3.Selection<SVGGElement, d3.HierarchyNode<MindMapNode>, any, any>,
								node: d3.HierarchyNode<MindMapNode>,
								dimensions: any): void {
	// æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ AI æŒ‰é’®
	const existingAIButton = nodeElement.select(".ai-suggest-button-group");
	if (!existingAIButton.empty()) {
		return; // AI æŒ‰é’®å·²å­˜åœ¨åˆ™ä¸é‡å¤åˆ›å»º
	}

	// è®¡ç®—ä¸¤ä¸ªæŒ‰é’®çš„æ€»é«˜åº¦ï¼ˆ+å·æŒ‰é’®20px + é—´è·10px + AIæŒ‰é’®20px = 50pxï¼‰
	const totalButtonsHeight = 20 + 10 + 20;
	// AIæŒ‰é’®ä½äºä¸‹æ–¹ä½ç½®ï¼š+å·æŒ‰é’®Yä½ç½® + 20px (+å·æŒ‰é’®é«˜åº¦) + 10px (é—´è·)
	const buttonY = (dimensions.height - totalButtonsHeight) / 2 + 20 + 10;
	const buttonX = dimensions.width + 4; // ä¸+å·æŒ‰é’®æ°´å¹³å¯¹é½

	// åˆ›å»º AI å»ºè®®æŒ‰é’®ç»„
	const buttonGroup = nodeElement.append("g")
		.attr("class", "ai-suggest-button-group")
		.attr("transform", `translate(${buttonX}, ${buttonY})`);

	// æ·»åŠ ç‚¹å‡»äº‹ä»¶å¤„ç†å™¨
	buttonGroup.on("click", (event: MouseEvent) => {
		event.stopPropagation();
		this.triggerAISuggestions(node);
	});

	// åˆ›å»ºåœ†å½¢èƒŒæ™¯ï¼ˆç´«è‰²ï¼‰
	buttonGroup.append("circle")
		.attr("class", "ai-suggest-button-bg")
		.attr("cx", 10)
		.attr("cy", 10)
		.attr("r", 10)
		.attr("fill", "#9333ea")  // ç´«è‰²èƒŒæ™¯
		.style("opacity", 0.9)
		.style("cursor", "pointer");

	// åˆ›å»º emoji å›¾æ ‡
	buttonGroup.append("text")
		.attr("class", "ai-suggest-button-text")
		.attr("x", 10)
		.attr("y", 10)
		.attr("text-anchor", "middle")
		.attr("dominant-baseline", "middle")
		.attr("fill", "white")
		.attr("font-size", "14px")
		.style("pointer-events", "none")
		.text("âœ¨");

	// æ·»åŠ æ ‡é¢˜æç¤º
	buttonGroup.append("title")
		.text("AI Suggestions");
}

/**
 * ç§»é™¤ AI å»ºè®®æŒ‰é’®
 */
private removeAISuggestButton(nodeElement: d3.Selection<SVGGElement, d3.HierarchyNode<MindMapNode>, any, any>): void {
	const buttonGroup = nodeElement.select(".ai-suggest-button-group");
	if (!buttonGroup.empty()) {
		buttonGroup.remove();
	}
}

/**
 * è§¦å‘ AI å»ºè®®è¯·æ±‚
 */
private async triggerAISuggestions(node: d3.HierarchyNode<MindMapNode>): Promise<void> {

	if (!this.mindMapService) {
		console.error('[D3 Renderer] Mind map service not available');
		new Notice(this.messages.errors.serviceNotAvailable);
		return;
	}

	// ç©ºèŠ‚ç‚¹éªŒè¯
	const nodeText = node.data.text?.trim() || '';

	if (!nodeText) {
		console.warn('[D3 Renderer] Empty node detected, aborting AI suggestion');
		new Notice(this.messages.errors.emptyNodeError);
		return;
	}

	// æ¸…ç†ä¹‹å‰çš„åŠ è½½æç¤ºï¼ˆå¦‚æœå­˜åœ¨ï¼‰
	if (this.loadingNotice) {
		this.loadingNotice.hide();
		this.loadingNotice = null;
	}

	// æ˜¾ç¤ºæŒä¹…åŒ–çš„åŠ è½½æç¤ºï¼ˆæ— è¶…æ—¶ï¼Œä¼šæŒç»­æ˜¾ç¤ºç›´åˆ°æ‰‹åŠ¨éšè—ï¼‰
	this.loadingNotice = new Notice(this.messages.format(
		this.messages.notices.aiAnalyzing,
		{ nodeText }
	), 0);

	try {
		// è°ƒç”¨ MindMapService è·å–å»ºè®®
		const suggestions = await this.mindMapService.suggestChildNodes(node.data);

		// æˆåŠŸåéšè—åŠ è½½æç¤º
		if (this.loadingNotice) {
			this.loadingNotice.hide();
			this.loadingNotice = null;
		}

		if (suggestions.length === 0) {
			console.warn('[D3 Renderer] No suggestions generated');
			new Notice(this.messages.notices.aiNoSuggestions);
			return;
		}

		// æ˜¾ç¤ºå»ºè®®é¢æ¿
		this.showSuggestionsPanel(node, suggestions);
	} catch (error) {
		console.error('[D3 Renderer] Failed to get AI suggestions:', error);

		// é”™è¯¯æ—¶ä¹Ÿéšè—åŠ è½½æç¤º
		if (this.loadingNotice) {
			this.loadingNotice.hide();
			this.loadingNotice = null;
		}

		const errorMsg = this.messages.format(
			this.messages.notices.aiFailed,
			{ error: error.message }
		);
		new Notice(errorMsg);
	}

}

/**
 * æ˜¾ç¤ºå»ºè®®åˆ—è¡¨é¢æ¿
 */
private showSuggestionsPanel(node: d3.HierarchyNode<MindMapNode>, suggestions: string[]): void {
	// ç§»é™¤æ—§é¢æ¿
	this.hideSuggestionsPanel();

	// åˆ›å»ºé¢æ¿å®¹å™¨
	const panel = document.createElement("div");
	panel.className = "ai-suggestions-panel";

	// æ ‡é¢˜å’Œæ“ä½œæŒ‰é’®åŒºåŸŸ
	const header = document.createElement("div");
	header.className = "ai-suggestions-header";

	const title = document.createElement("h4");
	title.textContent = this.messages.ui.aiSuggestionsTitle;

	// æ“ä½œæŒ‰é’®å®¹å™¨
	const actionButtons = document.createElement("div");
	actionButtons.className = "ai-suggestions-actions";

	// å…¨é€‰æŒ‰é’®
	const selectAllBtn = document.createElement("button");
	selectAllBtn.className = "ai-suggestions-select-all";
	selectAllBtn.textContent = this.messages.ui.aiAddAll;
	selectAllBtn.title = this.messages.ui.aiAddAllTooltip;
	selectAllBtn.onclick = () => {
		suggestions.forEach(suggestion => {
			if (!this.selectedSuggestions.has(suggestion)) {
				// æŸ¥æ‰¾å¯¹åº”çš„åˆ—è¡¨é¡¹
				const listItem = Array.from(list.children).find(
					item => item.textContent?.includes(suggestion)
				) as HTMLElement;
				this.createChildFromSuggestion(node, suggestion, listItem);
			}
		});
	};

	// å…³é—­æŒ‰é’®
	const closeBtn = document.createElement("button");
	closeBtn.className = "ai-suggestions-close";
	closeBtn.textContent = this.messages.ui.aiClose;
	closeBtn.onclick = () => this.hideSuggestionsPanel();

	actionButtons.appendChild(selectAllBtn);
	actionButtons.appendChild(closeBtn);
	header.appendChild(title);
	header.appendChild(actionButtons);
	panel.appendChild(header);

	// å»ºè®®åˆ—è¡¨
	const list = document.createElement("ul");
	list.className = "ai-suggestions-list";

	suggestions.forEach((suggestion, index) => {
		const item = document.createElement("li");
		item.className = "ai-suggestion-item";

		// æ£€æŸ¥æ˜¯å¦å·²é€‰æ‹©ï¼ˆç”¨äºé¢æ¿é‡æ–°æ‰“å¼€çš„æƒ…å†µï¼‰
		const isSelected = this.selectedSuggestions.has(suggestion);
		if (isSelected) {
			item.classList.add('ai-suggestion-item-selected');
		}

		// åˆ›å»ºå¯¹å‹¾å ä½å…ƒç´ 
		const checkmark = document.createElement("span");
		checkmark.className = "ai-suggestion-checkmark";
		checkmark.textContent = isSelected ? 'âœ“' : '';

		// åˆ›å»ºå»ºè®®æ–‡æœ¬
		const text = document.createElement("span");
		text.className = "ai-suggestion-text";
		text.textContent = suggestion;

		item.appendChild(checkmark);
		item.appendChild(text);

		// ç‚¹å‡»äº‹ä»¶ï¼šå¦‚æœæœªé€‰æ‹©æ‰åˆ›å»º
		item.onclick = () => {
			if (!this.selectedSuggestions.has(suggestion)) {
				this.createChildFromSuggestion(node, suggestion, item);
			} else {
				new Notice(this.messages.format(
					this.messages.notices.alreadyAdded || `Already added: {nodeText}`,
					{ nodeText: suggestion }
				));
			}
		};

		list.appendChild(item);
	});

	panel.appendChild(list);

	// æ·»åŠ åˆ° document.bodyï¼ˆé¿å…è¢«é‡æ–°æ¸²æŸ“ç§»é™¤ï¼‰
	document.body.appendChild(panel);
}

/**
 * å…³é—­å»ºè®®é¢æ¿
 */
private hideSuggestionsPanel(): void {
	const panel = document.querySelector(".ai-suggestions-panel");
	if (panel) {
		panel.remove();
	}
}

/**
 * ä»å»ºè®®åˆ›å»ºå­èŠ‚ç‚¹
 */
private createChildFromSuggestion(
	parentNode: d3.HierarchyNode<MindMapNode>,
	suggestion: string,
	listItemElement?: HTMLElement
): void {
	if (!this.mindMapService) {
		return;
	}

	// é˜²æ­¢é‡å¤åˆ›å»ºç›¸åŒå»ºè®®
	if (this.selectedSuggestions.has(suggestion)) {
		new Notice(this.messages.format(
			this.messages.notices.alreadyAdded || `Already added: {nodeText}`,
			{ nodeText: suggestion }
		));
		return;
	}

	try {
		// åˆ›å»ºå­èŠ‚ç‚¹
		this.mindMapService.createChildNode(parentNode.data, suggestion);

		// è¿½è¸ªå·²é€‰æ‹©çš„å»ºè®®
		this.selectedSuggestions.add(suggestion);

		// åˆ·æ–°æ¸²æŸ“
		this.onDataUpdated?.();

		// æ ‡è®°åˆ—è¡¨é¡¹ä¸ºå·²é€‰æ‹©ï¼ˆå¦‚æœæä¾›äº†åˆ—è¡¨é¡¹å…ƒç´ ï¼‰
		if (listItemElement) {
			listItemElement.classList.add('ai-suggestion-item-selected');
			// æ˜¾ç¤ºå¯¹å‹¾å›¾æ ‡
			const checkmark = listItemElement.querySelector('.ai-suggestion-checkmark');
			if (checkmark) {
				checkmark.textContent = 'âœ“';
			}
		}

		// æ˜¾ç¤ºæˆåŠŸæç¤º
		new Notice(this.messages.format(
			this.messages.notices.nodeCreated || `Created: {nodeText}`,
			{ nodeText: suggestion }
		));

		// ä¸å†è‡ªåŠ¨å…³é—­é¢æ¿ï¼Œå…è®¸ç”¨æˆ·ç»§ç»­é€‰æ‹©å…¶ä»–å»ºè®®
	} catch (error) {
		console.error("Failed to create child node:", error);
		new Notice(this.messages.format(
			this.messages.notices.nodeCreateFailed || `Failed to create node: {error}`,
			{ error: error.message }
		));
	}
}

// ========== ç§»åŠ¨ç«¯å·¥å…·æ ç›¸å…³æ–¹æ³• ==========

/**
 * åˆå§‹åŒ–å…±äº«å·¥å…·æ ï¼ˆç§»åŠ¨ç«¯ä¸“ç”¨ï¼‰
 * åœ¨ SVG æ ¹çº§åˆ«åˆ›å»ºå•ä¸€å·¥å…·æ ï¼Œç¡®ä¿åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¹‹åæ¸²æŸ“
 */
private initializeSharedToolbar(content: d3.Selection<SVGGElement, unknown, null, undefined>): void {
	// åˆ›å»ºå…±äº«å·¥å…·æ ç»„ï¼ˆåœ¨æ‰€æœ‰èŠ‚ç‚¹ä¹‹åï¼Œè‡ªåŠ¨åœ¨æœ€ä¸Šå±‚ï¼‰
	this.sharedToolbar = content.append("g")
		.attr("class", "shared-node-toolbar")
		.style("display", "none");  // åˆå§‹éšè—

	// åˆ›å»ºå·¥å…·æ å†…å®¹ï¼ˆä¸ç°æœ‰è®¾è®¡å®Œå…¨ç›¸åŒï¼‰
	this.createToolbarContent(this.sharedToolbar);
}

/**
 * åˆ›å»ºå·¥å…·æ å†…å®¹
 * ä¸ç°æœ‰å·¥å…·æ è®¾è®¡ä¿æŒä¸€è‡´ï¼š400Ã—44pxï¼Œé»‘è‰²èƒŒæ™¯ï¼Œå››ä¸ªæŒ‰é’®
 */
private createToolbarContent(toolbarGroup: d3.Selection<SVGGElement, unknown, null, undefined>): void {
	const toolbarWidth = 400;
	const toolbarHeight = 44;

	// å·¥å…·æ èƒŒæ™¯ï¼ˆé»‘è‰²åœ†è§’çŸ©å½¢ï¼‰
	toolbarGroup.append("rect")
		.attr("class", "toolbar-bg")
		.attr("width", toolbarWidth)
		.attr("height", toolbarHeight)
		.attr("rx", 8)
		.attr("ry", 8)
		.attr("fill", "#000000");

	// å·¥å…·æ ç®­å¤´ï¼ˆæŒ‡å‘èŠ‚ç‚¹ï¼‰
	toolbarGroup.append("path")
		.attr("class", "toolbar-arrow")
		.attr("d", "M 200 52 L 192 44 L 208 44 Z")
		.attr("fill", "#000000");

	// ä¸‰æ¡åˆ†éš”çº¿
	for (let i = 1; i <= 3; i++) {
		toolbarGroup.append("line")
			.attr("class", "toolbar-separator")
			.attr("x1", (toolbarWidth / 4) * i)
			.attr("y1", 8)
			.attr("x2", (toolbarWidth / 4) * i)
			.attr("y2", toolbarHeight - 8)
			.attr("stroke", "#333333")
			.attr("stroke-width", 1);
	}

	// åˆ›å»ºå››ä¸ªæŒ‰é’®
	this.createToolbarButton(toolbarGroup, 0, toolbarWidth, toolbarHeight, "edit");
	this.createToolbarButton(toolbarGroup, 1, toolbarWidth, toolbarHeight, "copy");
	this.createToolbarButton(toolbarGroup, 2, toolbarWidth, toolbarHeight, "paste");
	this.createToolbarButton(toolbarGroup, 3, toolbarWidth, toolbarHeight, "delete");
}

/**
 * åˆ›å»ºå·¥å…·æ æŒ‰é’®
 */
private createToolbarButton(
	toolbarGroup: d3.Selection<SVGGElement, unknown, null, undefined>,
	index: number,
	toolbarWidth: number,
	toolbarHeight: number,
	type: string
): void {
	const buttonGroup = toolbarGroup.append("g")
		.attr("class", `toolbar-btn ${type}-btn`)
		.style("cursor", "pointer");

	buttonGroup.append("rect")
		.attr("x", (toolbarWidth / 4) * index)
		.attr("width", toolbarWidth / 4)
		.attr("height", toolbarHeight)
		.attr("fill", "transparent")
		.attr("rx", 8)
		.attr("ry", 8);

	// æŒ‰é’®å›¾æ ‡å’Œæ–‡æœ¬é…ç½®
	const buttonConfig = {
		edit: { icon: "âœï¸", text: this.messages.ui.contextEdit },
		copy: { icon: "ğŸ“‹", text: this.messages.ui.contextCopy },
		paste: { icon: "ğŸ“‘", text: this.messages.ui.contextPaste },
		delete: { icon: "ğŸ—‘ï¸", text: this.messages.ui.contextDelete }
	};

	const config = buttonConfig[type as keyof typeof buttonConfig];
	const buttonCenterX = (toolbarWidth / 4) * index + (toolbarWidth / 8);

	buttonGroup.append("text")
		.attr("x", buttonCenterX - 16)
		.attr("y", toolbarHeight / 2)
		.attr("dominant-baseline", "middle")
		.attr("text-anchor", "middle")
		.attr("fill", "#ffffff")
		.attr("font-size", "14px")
		.style("pointer-events", "none")
		.text(config.icon);

	buttonGroup.append("text")
		.attr("x", buttonCenterX + 16)
		.attr("y", toolbarHeight / 2)
		.attr("dominant-baseline", "middle")
		.attr("text-anchor", "middle")
		.attr("fill", "#ffffff")
		.attr("font-size", "14px")
		.attr("font-weight", "500")
		.style("pointer-events", "none")
		.text(config.text);
}

/**
 * æ›´æ–°å…±äº«å·¥å…·æ ä½ç½®å’Œæ˜¾ç¤ºçŠ¶æ€
 * æ ¹æ®é€‰ä¸­çš„èŠ‚ç‚¹åŠ¨æ€å®šä½å·¥å…·æ 
 */
private updateSharedToolbar(
	node: d3.HierarchyNode<MindMapNode>,
	offsetX: number,
	offsetY: number
): void {
	if (!this.sharedToolbar) {
		return;
	}

	// è·å–èŠ‚ç‚¹å°ºå¯¸
	const dimensions = this.textMeasurer.getNodeDimensions(node.depth, node.data.text);

	// è®¡ç®—å·¥å…·æ ç»å¯¹ä½ç½®ï¼ˆå…³é”®ï¼šä½¿ç”¨ç”»å¸ƒåæ ‡ï¼‰
	const nodeCanvasX = node.y + offsetX;  // èŠ‚ç‚¹çš„æ°´å¹³ä½ç½®
	// ä¿®å¤ï¼šnode.x æ˜¯å¸ƒå±€åæ ‡çš„ä¸­å¿ƒç‚¹ï¼Œéœ€è¦è½¬æ¢ä¸ºç”»å¸ƒåæ ‡çš„é¡¶è¾¹ä½ç½®
	const nodeCanvasY = node.x + offsetY - dimensions.height / 2;  // èŠ‚ç‚¹çš„å‚ç›´ä½ç½®ï¼ˆé¡¶è¾¹ï¼‰

	const toolbarWidth = 320;
	const toolbarHeight = 44;

	// å·¥å…·æ ç›¸å¯¹äºèŠ‚ç‚¹çš„åç§»ï¼ˆä¸ç°æœ‰å®ç°å®Œå…¨ä¸€è‡´ï¼‰
	const toolbarOffsetX = (dimensions.width - toolbarWidth) / 2;  // æ°´å¹³å±…ä¸­
	const toolbarOffsetY = -toolbarHeight - 12;  // èŠ‚ç‚¹ä¸Šæ–¹12px

	// å·¥å…·æ çš„ç»å¯¹åæ ‡
	const toolbarX = nodeCanvasX + toolbarOffsetX;
	const toolbarY = nodeCanvasY + toolbarOffsetY;

	// æ›´æ–°å·¥å…·æ ä½ç½®
	// ğŸ”§ ä¿®å¤ï¼šä¸­æ–­ä»»ä½•æ­£åœ¨è¿›è¡Œçš„è¿‡æ¸¡åŠ¨ç”»ï¼Œç¡®ä¿å·¥å…·æ ç«‹å³å“åº”
	this.sharedToolbar
		.interrupt()  // â† ä¸­æ–­æ­£åœ¨è¿›è¡Œçš„åŠ¨ç”»ï¼ˆå¦‚æ·¡å‡ºåŠ¨ç”»ï¼‰
		.attr("transform", `translate(${toolbarX}, ${toolbarY})`)
		.style("display", "block")
		.style("opacity", 0);

	// ä¿å­˜å½“å‰å…³è”çš„èŠ‚ç‚¹
	this.sharedToolbarNode = node;

	// æ›´æ–°æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨ï¼ˆä½¿ç”¨æ–°çš„èŠ‚ç‚¹å¼•ç”¨ï¼‰
	this.attachToolbarButtonHandlers(node);

	// å¹³æ»‘æ·¡å…¥åŠ¨ç”»
	requestAnimationFrame(() => {
		if (this.sharedToolbar) {
			this.sharedToolbar
				.style("transition", "opacity 0.15s ease-out")
				.style("opacity", 1);
		}
	});
}

/**
 * é™„åŠ å·¥å…·æ æŒ‰é’®äº‹ä»¶å¤„ç†å™¨
 */
private attachToolbarButtonHandlers(node: d3.HierarchyNode<MindMapNode>): void {
	if (!this.sharedToolbar) return;

	// ç¼–è¾‘æŒ‰é’®
	this.sharedToolbar.select(".edit-btn")
		.on("click", (event: MouseEvent) => {
			this.handleToolbarEditClick(event, node);
		});

	// å¤åˆ¶æŒ‰é’®
	this.sharedToolbar.select(".copy-btn")
		.on("click", (event: MouseEvent) => {
			this.handleToolbarCopyClick(event, node);
		});

	// ç²˜è´´æŒ‰é’®
	this.sharedToolbar.select(".paste-btn")
		.on("click", (event: MouseEvent) => {
			this.handleToolbarPasteClick(event, node);
		});

	// åˆ é™¤æŒ‰é’®
	this.sharedToolbar.select(".delete-btn")
		.on("click", (event: MouseEvent) => {
			this.handleToolbarDeleteClick(event, node);
		});
}

/**
 * éšè—å…±äº«å·¥å…·æ 
 */
private hideSharedToolbar(): void {
	if (!this.sharedToolbar) {
		return;
	}

	this.sharedToolbar
		.style("opacity", 0)
		.transition()
		.duration(150)
		.on("end", () => {
			this.sharedToolbar?.style("display", "none");
			// ğŸ”§ ä¿®å¤ï¼šåªåœ¨åŠ¨ç”»å®Œæˆåæ¸…é™¤èŠ‚ç‚¹å¼•ç”¨
			// è¿™æ · updateSharedToolbar() å¯ä»¥åœ¨åŠ¨ç”»æœŸé—´æ­£ç¡®æ›´æ–°å¼•ç”¨
			this.sharedToolbarNode = null;
		});

	// ğŸ”§ ä¿®å¤ï¼šç§»é™¤ç«‹å³æ¸…é™¤å¼•ç”¨çš„ä»£ç 
	// èŠ‚ç‚¹å¼•ç”¨ç°åœ¨åœ¨åŠ¨ç”»å®Œæˆåæ‰æ¸…é™¤
}

// æ³¨æ„ï¼šæ—§çš„å·¥å…·æ æ–¹æ³•å·²è¢«å…±äº«å·¥å…·æ æ›¿ä»£ï¼Œå·²åˆ é™¤ï¼š
// - renderNodeToolbars()
// - renderNodeToolbar()
// - removeNodeToolbar()
// - showNodeToolbar()
// - hideNodeToolbar()
// - hideAllToolbars()

// å¤„ç†+å·æŒ‰é’®ç‚¹å‡»äº‹ä»¶
private handlePlusButtonClick(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>): void {
	event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°èŠ‚ç‚¹

	// 1. åˆ›å»ºæ–°å­èŠ‚ç‚¹
	const newNode = this.mindMapService.createChildNode(node.data, "New Node");

	// 2. æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
	this.clearSelection();

	// 3. è®¾ç½®æ–°èŠ‚ç‚¹ä¸ºé€‰ä¸­çŠ¶æ€
	newNode.selected = true;
	// åˆ›å»ºä¸€ä¸ªç®€å•çš„å±‚çº§ç»“æ„å¯¹è±¡æ¥åŒ¹é…d3.HierarchyNodeçš„æ ¼å¼
	this.selectedNode = {
		data: newNode,
		depth: newNode.level,
		parent: node,
		children: [] as d3.HierarchyNode<MindMapNode>[]
	} as d3.HierarchyNode<MindMapNode>;

	// 4. è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
	this.onDataUpdated?.();

	// 5. å»¶è¿Ÿè‡ªåŠ¨è¿›å…¥ç¼–è¾‘æ¨¡å¼(ä½¿ç”¨requestAnimationFrameç¡®ä¿DOMå·²æ›´æ–°)
	requestAnimationFrame(() => {
		this.editNewNode();
	});
}

// ç¼–è¾‘æ–°åˆ›å»ºçš„èŠ‚ç‚¹(ä½¿ç”¨selectedNodeå¼•ç”¨)
private editNewNode(): void {
	// ç›´æ¥ä½¿ç”¨ this.selectedNode,å®ƒå·²ç»åœ¨ render ä¸­è¢«åŒæ­¥åˆ°æ­£ç¡®çš„D3å¼•ç”¨
	if (!this.selectedNode || !this.currentSvg) {
		console.warn("MindMap Plugin: No selected node to edit");
		return;
	}

	// é€šè¿‡D3èŠ‚ç‚¹å¯¹è±¡æ¯”è¾ƒ(è€Œéæ•°æ®å¯¹è±¡æ¯”è¾ƒ)æ‰¾åˆ°DOMå…ƒç´ 
	const nodeElements = d3.selectAll(".nodes g");
	const targetElement = nodeElements
		.filter((d: any) => d === this.selectedNode)
		.select(".node-unified-text")
		.node() as HTMLDivElement;

	if (targetElement) {
		// ä½¿ç”¨selectedNode,å®ƒå·²ç»æ˜¯æ­£ç¡®çš„D3å±‚çº§ç»“æ„å¯¹è±¡
		this.enableNodeEditing(this.selectedNode, targetElement);
	} else {
		console.error("MindMap Plugin: Could not find DOM element for selected node");
	}
}

// ========== ç§»åŠ¨ç«¯å·¥å…·æ äº‹ä»¶å¤„ç† ==========

// å¤„ç†å·¥å…·æ ç¼–è¾‘æŒ‰é’®ç‚¹å‡»
private handleToolbarEditClick(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>): void {
	event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡

	// éœ‡åŠ¨åé¦ˆï¼ˆå¦‚æœè®¾å¤‡æ”¯æŒï¼‰
	if (navigator.vibrate) {
		navigator.vibrate(50);
	}

	// æ‰¾åˆ°èŠ‚ç‚¹çš„DOMå…ƒç´ 
	const nodeElements = d3.selectAll(".nodes g");
	const targetElement = nodeElements
		.filter((d: any) => d.data === node.data)
		.select(".node-unified-text")
		.node() as HTMLDivElement;

	if (targetElement) {
		this.enableNodeEditing(node, targetElement);
	}
}

// å¤„ç†å·¥å…·æ å¤åˆ¶æŒ‰é’®ç‚¹å‡»
private handleToolbarCopyClick(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>): void {
	event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡

	// éœ‡åŠ¨åé¦ˆï¼ˆå¦‚æœè®¾å¤‡æ”¯æŒï¼‰
	if (navigator.vibrate) {
		navigator.vibrate(50);
	}

	// ğŸ”§ ä¿®æ”¹:åºåˆ—åŒ–æ•´ä¸ªå­æ ‘ä¸ºmarkdownæ ¼å¼
	const markdown = this.mindMapService.serializeSubtreeToMarkdown(node.data);

	// ä½¿ç”¨ Clipboard API å¤åˆ¶æ–‡æœ¬åˆ°å‰ªè´´æ¿
	if (navigator.clipboard && window.isSecureContext) {
		// ä½¿ç”¨ç°ä»£ Clipboard APIï¼ˆæ”¯æŒç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯ï¼‰
		navigator.clipboard.writeText(markdown).then(() => {
			// æ˜¾ç¤ºæˆåŠŸæç¤º
			this.showCopySuccessNotice(this.messages.notices.nodeTextCopied);
		}).catch((err) => {
			console.error('Failed to copy text: ', err);
			// é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
			this.fallbackCopyTextToClipboard(markdown);
		});
	} else {
		// é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
		this.fallbackCopyTextToClipboard(markdown);
	}
}

// é™çº§å¤åˆ¶æ–¹æ¡ˆï¼ˆå…¼å®¹æ—§æµè§ˆå™¨ï¼‰
private fallbackCopyTextToClipboard(text: string): void {
	const textArea = document.createElement("textarea");
	textArea.value = text;
	textArea.style.cssText = "position: fixed; top: 0; left: 0; width: 2em; height: 2em; padding: 0; border: none; outline: none; box-shadow: none; background: transparent; opacity: 0; pointer-events: none;";
	document.body.appendChild(textArea);
	textArea.focus();
	textArea.select();

	try {
		const successful = document.execCommand('copy');
		if (successful) {
			this.showCopySuccessNotice(this.messages.notices.nodeTextCopied);
		} else {
			console.error('Failed to copy text using execCommand');
			this.showCopyErrorNotice(this.messages.notices.copyFailed);
		}
	} catch (err) {
		console.error('Failed to copy text: ', err);
		this.showCopyErrorNotice(this.messages.notices.copyFailed);
	}

	document.body.removeChild(textArea);
}

// æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
private showCopySuccessNotice(message: string): void {
	new Notice(message, 2000);
}

// æ˜¾ç¤ºå¤åˆ¶å¤±è´¥æç¤º
private showCopyErrorNotice(message: string): void {
	new Notice(message, 3000);
}

// å¤„ç†å·¥å…·æ åˆ é™¤æŒ‰é’®ç‚¹å‡»
private handleToolbarDeleteClick(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>): void {
	event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡

	// éœ‡åŠ¨åé¦ˆï¼ˆå¦‚æœè®¾å¤‡æ”¯æŒï¼‰
	if (navigator.vibrate) {
		navigator.vibrate(50);
	}

	// è°ƒç”¨æœåŠ¡å±‚åˆ é™¤èŠ‚ç‚¹ï¼ˆæœåŠ¡å±‚ä¼šå¤„ç†æ ¹èŠ‚ç‚¹æ£€æŸ¥å¹¶æ˜¾ç¤ºé€šçŸ¥ï¼‰
	const deleteSuccess = this.mindMapService.deleteNode(node.data);

	if (deleteSuccess) {
		// æ¸…é™¤é€‰ä¸­çŠ¶æ€
		this.clearSelection();

		// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
		this.onDataUpdated?.();
	}
	// æ³¨æ„ï¼šåˆ é™¤å¤±è´¥æ—¶ï¼ŒæœåŠ¡å±‚å·²ç»æ˜¾ç¤ºäº†ç›¸åº”çš„ Notice æç¤º
}

/*// å¤„ç† Ctrl+C / Cmd+C å¿«æ·é”® - å¤åˆ¶èŠ‚ç‚¹æ–‡æœ¬*/
/*private handleCopyShortcut(): void {*/
/*	// æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„èŠ‚ç‚¹*/
/*	if (!this.selectedNode) {*/
/*		return; // é™é»˜å¤±è´¥*/
/*	}*/
/**/
/*	// ğŸ”§ ä¿®æ”¹:åºåˆ—åŒ–æ•´ä¸ªå­æ ‘ä¸ºmarkdownæ ¼å¼*/
/*	const markdown = this.mindMapService.serializeSubtreeToMarkdown(this.selectedNode.data);*/
/**/
/*	// ä½¿ç”¨ Clipboard API å¤åˆ¶*/
/*	if (navigator.clipboard && window.isSecureContext) {*/
/*		navigator.clipboard.writeText(markdown).then(() => {*/
/*			this.showCopySuccessNotice(this.messages.notices.nodeTextCopied);*/
/*		}).catch((err) => {*/
/*			console.error('Failed to copy subtree: ', err);*/
/*			this.fallbackCopyTextToClipboard(markdown);*/
/*		});*/
/*	} else {*/
/*		this.fallbackCopyTextToClipboard(markdown);*/
/*	}*/
/*}*/
/**/
/*// å¤„ç† Ctrl+X / Cmd+X å¿«æ·é”® - å‰ªåˆ‡èŠ‚ç‚¹ï¼ˆå¤åˆ¶+åˆ é™¤ï¼‰*/
/*private handleCutShortcut(): void {*/
/*	// æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„èŠ‚ç‚¹*/
/*	if (!this.selectedNode) {*/
/*		return; // é™é»˜å¤±è´¥*/
/*	}*/
/**/
/*	// å…ˆæ‰§è¡Œå¤åˆ¶æ“ä½œ*/
/*	this.handleCopyShortcut();*/
/**/
/*	// ç„¶åæ‰§è¡Œåˆ é™¤æ“ä½œï¼ˆä¼šè‡ªåŠ¨å¤„ç†æ ¹èŠ‚ç‚¹æ£€æŸ¥å’ŒçŠ¶æ€æ¸…ç†ï¼‰*/
/*	this.handleDeleteKey();*/
/*}*/
/**/
/*// å¤„ç† Ctrl+V / Cmd+V å¿«æ·é”® - ç²˜è´´åˆ›å»ºå­èŠ‚ç‚¹æˆ–å­æ ‘*/
/*private handlePasteShortcut(): void {*/
/*	// æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„èŠ‚ç‚¹*/
/*	if (!this.selectedNode) {*/
/*		return; // é™é»˜å¤±è´¥*/
/*	}*/
/**/
/*	const node = this.selectedNode;*/
/**/
/*	// ä½¿ç”¨ Clipboard API è¯»å–*/
/*	if (navigator.clipboard && window.isSecureContext) {*/
/*		navigator.clipboard.readText().then((clipboardText) => {*/
/*			if (!clipboardText || clipboardText.trim().length === 0) {*/
/*				return; // é™é»˜å¤±è´¥*/
/*			}*/
/**/
/*			// ğŸ”§ ä¿®æ”¹:æ™ºèƒ½åˆ¤æ–­å‰ªè´´æ¿å†…å®¹æ ¼å¼*/
/*			const trimmedText = clipboardText.trim();*/
/**/
/*			// åˆ¤æ–­æ˜¯å¦ä¸ºmarkdownæ ¼å¼(ä»¥'*'æˆ–'-'å¼€å¤´ä¸”æœ‰ç¼©è¿›)*/
/*			const isMarkdownFormat = /^\s*[\*\-]/m.test(clipboardText);*/
/**/
/*			if (isMarkdownFormat) {*/
/*				// æ˜¯markdownæ ¼å¼ â†’ åˆ›å»ºå­æ ‘*/
/*				const subtreeRoot = this.mindMapService.createSubtreeFromMarkdown(*/
/*					clipboardText,*/
/*					node.data.level*/
/*				);*/
/**/
/*				if (subtreeRoot) {*/
/*					// æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹çš„childrenæ•°ç»„*/
/*					subtreeRoot.parent = node.data;*/
/*					node.data.children.push(subtreeRoot);*/
/**/
/*					// é€‰ä¸­æ–°åˆ›å»ºçš„å­æ ‘æ ¹èŠ‚ç‚¹(ä¸è¿›å…¥ç¼–è¾‘æ¨¡å¼)*/
/*					subtreeRoot.selected = true;*/
/*					this.clearSelection();*/
/*					this.selectedNode = {*/
/*						data: subtreeRoot,*/
/*						depth: subtreeRoot.level,*/
/*						parent: node,*/
/*						children: [] as d3.HierarchyNode<MindMapNode>[]*/
/*					} as d3.HierarchyNode<MindMapNode>;*/
/**/
/*					// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“*/
/*					this.onDataUpdated?.();*/
/*				}*/
/*			} else {*/
/*				// æ™®é€šæ–‡æœ¬ â†’ åˆ›å»ºå•ä¸ªå­èŠ‚ç‚¹*/
/*				const truncatedText = trimmedText.substring(0, 100);*/
/*				const childNode = this.mindMapService.createChildNode(node.data, truncatedText);*/
/**/
/*				// æ¸…é™¤å½“å‰é€‰æ‹©*/
/*				this.clearSelection();*/
/**/
/*				// é€‰ä¸­æ–°åˆ›å»ºçš„å­èŠ‚ç‚¹(ä¸è¿›å…¥ç¼–è¾‘æ¨¡å¼)*/
/*				childNode.selected = true;*/
/*				this.selectedNode = {*/
/*					data: childNode,*/
/*					depth: childNode.level,*/
/*					parent: node,*/
/*					children: [] as d3.HierarchyNode<MindMapNode>[]*/
/*				} as d3.HierarchyNode<MindMapNode>;*/
/**/
/*				// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“*/
/*				this.onDataUpdated?.();*/
/*			}*/
/*		}).catch((err) => {*/
/*			// é™é»˜å¤±è´¥*/
/*			console.error('Failed to read clipboard: ', err);*/
/*		});*/
/*	}*/
/*}*/

// å¤„ç†å·¥å…·æ ç²˜è´´æŒ‰é’®ç‚¹å‡»
private handleToolbarPasteClick(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>): void {
	event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡

	// éœ‡åŠ¨åé¦ˆï¼ˆå¦‚æœè®¾å¤‡æ”¯æŒï¼‰
	if (navigator.vibrate) {
		navigator.vibrate(50);
	}

	// ä½¿ç”¨ Clipboard API è¯»å–å‰ªè´´æ¿å†…å®¹
	if (navigator.clipboard && window.isSecureContext) {
		// ä½¿ç”¨ç°ä»£ Clipboard API
		navigator.clipboard.readText().then((clipboardText) => {
			// é™é»˜å¤±è´¥ï¼šå¦‚æœå‰ªè´´æ¿ä¸ºç©ºæˆ–æ— æ³•è¯»å–ï¼Œç›´æ¥è¿”å›
			if (!clipboardText || clipboardText.trim().length === 0) {
				return;
			}

			// æ£€æŸ¥å‰ªè´´æ¿å†…å®¹æ˜¯å¦ä¸ºmarkdownæ ¼å¼ï¼ˆåŒ…å«åˆ—è¡¨æ ‡è®°ï¼‰
			const isMarkdownFormat = /^\s*[\*\-]/m.test(clipboardText);

			if (isMarkdownFormat) {
				// å¦‚æœæ˜¯markdownæ ¼å¼ï¼Œå°è¯•åˆ›å»ºå­æ ‘
				const subtreeRoot = this.mindMapService.createSubtreeFromMarkdown(
					clipboardText,
					node.data.level
				);

				if (subtreeRoot) {
					// è®¾ç½®çˆ¶èŠ‚ç‚¹
					subtreeRoot.parent = node.data;
					node.data.children.push(subtreeRoot);

					// æ¸…é™¤å½“å‰é€‰æ‹©
					this.clearSelection();

					// é€‰ä¸­æ–°åˆ›å»ºçš„å­æ ‘çš„æ ¹èŠ‚ç‚¹(ä¸è¿›å…¥ç¼–è¾‘æ¨¡å¼)
					subtreeRoot.selected = true;
					this.selectedNode = {
						data: subtreeRoot,
						depth: subtreeRoot.level,
						parent: node,
						children: [] as d3.HierarchyNode<MindMapNode>[]
					} as d3.HierarchyNode<MindMapNode>;

					// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
					this.onDataUpdated?.();
				} else {
					// å¦‚æœè§£æå¤±è´¥ï¼Œå›é€€åˆ°æ™®é€šæ–‡æœ¬å¤„ç†
					const truncatedText = clipboardText.substring(0, 100);
					const childNode = this.mindMapService.createChildNode(node.data, truncatedText);

					this.clearSelection();
					childNode.selected = true;
					this.selectedNode = {
						data: childNode,
						depth: childNode.level,
						parent: node,
						children: [] as d3.HierarchyNode<MindMapNode>[]
					} as d3.HierarchyNode<MindMapNode>;

					this.onDataUpdated?.();
				}
			} else {
				// æ™®é€šæ–‡æœ¬ï¼Œåˆ›å»ºå•ä¸ªå­èŠ‚ç‚¹
				const truncatedText = clipboardText.substring(0, 100);
				const childNode = this.mindMapService.createChildNode(node.data, truncatedText);

				// æ¸…é™¤å½“å‰é€‰æ‹©
				this.clearSelection();

				// é€‰ä¸­æ–°åˆ›å»ºçš„å­èŠ‚ç‚¹(ä¸è¿›å…¥ç¼–è¾‘æ¨¡å¼)
				childNode.selected = true;
				this.selectedNode = {
					data: childNode,
					depth: childNode.level,
					parent: node,
					children: [] as d3.HierarchyNode<MindMapNode>[]
				} as d3.HierarchyNode<MindMapNode>;

				// è§¦å‘æ•°æ®æ›´æ–°å’Œé‡æ–°æ¸²æŸ“
				this.onDataUpdated?.();
			}
		}).catch((err) => {
			// é™é»˜å¤±è´¥ï¼šä¸æ˜¾ç¤ºä»»ä½•é”™è¯¯æç¤º
			console.error('Failed to read clipboard: ', err);
		});
	}
}

// è§¦å‘ç¼–è¾‘æ¨¡å¼
private triggerEdit(event: MouseEvent, node: d3.HierarchyNode<MindMapNode>): void {
	try {
		// ç®€åŒ–çš„æŸ¥æ‰¾é€»è¾‘ï¼šç›´æ¥ä»äº‹ä»¶ç›®æ ‡æŸ¥æ‰¾ç»Ÿä¸€çš„æ–‡æœ¬å…ƒç´ 
		let editElement: HTMLDivElement | null = null;

		// æ–¹æ³•1: ä»äº‹ä»¶ç›®æ ‡æŸ¥æ‰¾
		editElement = d3.select(event.currentTarget as Element)
			.select(".node-unified-text")
			.node() as HTMLDivElement;

		// æ–¹æ³•2: å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•ä»å­å…ƒç´ æŸ¥æ‰¾
		if (!editElement) {
			const targetElement = event.target as HTMLElement;
			editElement = targetElement.closest(".node-unified-text") as HTMLDivElement;
		}

		if (!editElement) {
			this.showValidationError("æ— æ³•æ‰¾åˆ°æ–‡æœ¬å…ƒç´ ");
			return;
		}

		this.handleNodeEdit(event, node, editElement);

	} catch (error) {
		this.showValidationError("è¿›å…¥ç¼–è¾‘æ¨¡å¼æ—¶å‘ç”Ÿé”™è¯¯");
	}
}

// æ¸²æŸ“èŠ‚ç‚¹äº‹ä»¶ï¼ˆèŠ‚ç‚¹çŸ©å½¢å·²ç”±NodeRendereræ¸²æŸ“ï¼Œæ–‡æœ¬å·²ç”±TextRendereræ¸²æŸ“ï¼‰- å·²åºŸå¼ƒï¼Œä½¿ç”¨ MouseInteraction
/*
private renderNodesTextAndEvents(nodeElements: d3.Selection<SVGGElement, d3.HierarchyNode<MindMapNode>, SVGGElement, unknown>): void {
	// æ·»åŠ äº‹ä»¶å¤„ç†å™¨ï¼ˆç‚¹å‡»å’Œæ‚¬åœï¼‰
	nodeElements.each((d, i, nodes) => {
		const nodeElement = d3.select(nodes[i]);
		const nodeRect = d3.select(nodes[i]).select(".node-rect");

		// ç‚¹å‡»äº‹ä»¶å¤„ç†å™¨
		nodeElement.on("click", (event: MouseEvent) => {
			this.handleNodeSelection(event, d, nodeRect as any);
		});

		// é¼ æ ‡æ‚¬åœäº‹ä»¶å¤„ç†å™¨
		nodeElement.on("mouseenter", (event: MouseEvent) => {
			this.handleNodeHover(event, d, nodeRect as any);
		});

		// é¼ æ ‡ç¦»å¼€äº‹ä»¶å¤„ç†å™¨
		nodeElement.on("mouseleave", (event: MouseEvent) => {
			this.handleNodeLeave(event, d, nodeRect as any);
		});
	});

	// æ¸²æŸ“é€‰ä¸­èŠ‚ç‚¹çš„+å·æŒ‰é’®
	this.renderPlusButtons(nodeElements);

	// æ³¨æ„ï¼šç§»åŠ¨ç«¯å·¥å…·æ å·²æ”¹ä¸ºå…±äº«å·¥å…·æ ï¼Œä¸å†åœ¨æ­¤å¤„æ¸²æŸ“
	// å…±äº«å·¥å…·æ åœ¨èŠ‚ç‚¹é€‰æ‹©æ—¶é€šè¿‡ updateSharedToolbar() æ˜¾ç¤º
}
*/

// æ·»åŠ ç”»å¸ƒç‚¹å‡»äº‹ä»¶å¤„ç†å™¨ï¼ˆç”¨äºå–æ¶ˆé€‰æ‹©ï¼‰
private addCanvasClickHandler(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>): void {
		// ç›´æ¥åœ¨SVGå…ƒç´ ä¸Šç›‘å¬ç‚¹å‡»äº‹ä»¶ï¼Œä½¿ç”¨æ•è·é˜¶æ®µç¡®ä¿ä¼˜å…ˆå¤„ç†
		const svgNode = svg.node() as SVGSVGElement;

		svgNode.addEventListener("click", (event: MouseEvent) => {
			// æ£€æŸ¥ç‚¹å‡»çš„ç›®æ ‡æ˜¯å¦ä¸ºç©ºç™½åŒºåŸŸ
			const target = event.target as SVGElement;

			// æ£€æŸ¥ç‚¹å‡»çš„ç›®æ ‡ç±»å‹
			const targetTagName = target.tagName.toLowerCase();
			const targetClasses = target.classList;

			// æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èŠ‚ç‚¹ç›¸å…³çš„å…ƒç´ 
			const isNodeElement = (
				targetTagName === 'g' && targetClasses.contains('node') ||      // èŠ‚ç‚¹ç»„
				targetClasses.contains('node-rect') ||                         // èŠ‚ç‚¹çŸ©å½¢
				targetClasses.contains('node-text-layer') ||                    // èŠ‚ç‚¹æ–‡æœ¬å±‚
				targetTagName === 'foreignobject' ||                            // èŠ‚ç‚¹foreignObject
				targetTagName === 'div' ||                                     // èŠ‚ç‚¹æ–‡æœ¬div
				(targetTagName === 'g' && targetClasses.contains('node-group')) // å…¶ä»–å¯èƒ½çš„èŠ‚ç‚¹ç»„
			);

			// å¦‚æœæ²¡æœ‰ç‚¹å‡»èŠ‚ç‚¹å…ƒç´ ï¼Œåˆ™æ¸…é™¤é€‰æ‹©
			if (!isNodeElement) {
				this.clearSelection();
			}
		}, true); // ä½¿ç”¨æ•è·é˜¶æ®µ

	}

	// æ¸…é™¤æ‰€æœ‰èŠ‚ç‚¹é€‰æ‹©çŠ¶æ€
	private clearSelection(): void {
		// å¦‚æœæ­£åœ¨ç¼–è¾‘ï¼Œå…ˆä¿å­˜ç¼–è¾‘å†…å®¹(å‚ç…§Enteré”®å¤„ç†)
		if (this.editingState.isEditing) {
			this.saveNodeText();
			// saveNodeText ä¼šè°ƒç”¨ exitEditMode æ¸…ç†UI,æ‰€ä»¥è¿™é‡Œç›´æ¥è¿”å›
			return;
		}

		if (this.selectedNode) {
			// æ¸…é™¤é€‰ä¸­çŠ¶æ€
			this.selectedNode.data.selected = false;

			// ç§»é™¤æ‰€æœ‰èŠ‚ç‚¹çš„é«˜äº®è¾¹æ¡†
			d3.selectAll(".node-rect")
				.classed("selected-rect", false);

			// æ¸…é™¤é€‰ä¸­çš„èŠ‚ç‚¹å¼•ç”¨
			this.selectedNode = null;
		}

		// ç§»é™¤æ‰€æœ‰+å·æŒ‰é’®
		d3.selectAll(".plus-button-group").remove();

		// ç§»é™¤æ‰€æœ‰AIå»ºè®®æŒ‰é’®
		d3.selectAll(".ai-suggest-button-group").remove();

		// ç§»åŠ¨ç«¯ï¼šéšè—å…±äº«å·¥å…·æ 
		this.hideSharedToolbar();

		// æ¸…é™¤æ‰€æœ‰æ‚¬åœçŠ¶æ€
		this.clearHoverState();
	}
}
